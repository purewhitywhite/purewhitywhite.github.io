[{"title":"Stage1Day1 Web","date":"2020-03-08T11:46:09.000Z","path":"2020-03-08/Stage1Day1-Web/","text":"Blue-whale OJcalculator、RapidTyping、Basic PHP、Basic PHP 2 writeup. 今天是测试第一阶段的第一天。Keep posting! Calculator 从题目要求可以看到，需要在1.5s内计算出一个比较大的四则运算。按计算器估计是来不及了，由hint我们知道用Python来实现。先贴代码： 12345678910111213import requestsfrom bs4 import BeautifulSoupurl = \"http://vps1.blue-whale.me:23331/calculator/\"cal_session = requests.session()cal_respond = cal_session.get(url)# print(cal_respond.text)soup = BeautifulSoup(cal_respond.text, 'lxml')span = soup.find(\"span\", id=\"exp\")num = eval(span.text.replace('=', ''))# print(num)ans = &#123;\"answer\": num&#125;r = cal_session.get(url, params=ans)print(r.text) 代码分为几个阶段：首先使用了requests，它是基于urllib3的一个用于发起http请求的包；之后引入了比较常见的BeautifulSoup。创建一个session对象后，发送请求并获得返回的response对象。 接下来将其转为BeautifulSoup对象，找到其中id为exp的span标签，将其内容去掉最后的等号后作为参数传入eval函数，将计算结果封装为get的参数，再次请求得到返回的带有flag的网页。 通过这个入门题目可以练习常用包requests和BeautifulSoup的使用。 RapidTyping 这个题目跟上个题目有点相似，也是要求在短时间内完成验证码输入。题目给出hint说不是用图像识别啥的，那就看看网页源代码吧。 做过的CTF题目不多，多是入门题，发现这种比较入门的题目通常要结合Base64之类的东西来考察，或者是在前端做一些限制。把后面这堆结尾是等号的代码拖到Base64解码里会发现是一大堆形似html的代码，其中text标签中包含的就是图片中的字母。下面贴上代码： 12345678910111213141516171819202122import requestsfrom bs4 import BeautifulSoupimport base64url = \"http://vps1.blue-whale.me:23331/captcha/\"session = requests.session()respond = session.get(url)soup = BeautifulSoup(respond.text, \"lxml\")# print(soup.img.attrs[\"src\"])encoded = soup.img.attrs[\"src\"].lstrip(\"data:image/svg+xml;base64,\")# print(encoded)encoded = base64.b64decode(encoded)soup = BeautifulSoup(encoded, \"lxml\")decoded = soup.find_all(name=\"text\")ans = \"\"for i in range(500): for s in decoded: if i == int(s[\"x\"]): ans += str(s.text)# print(ans)answ = &#123;\"code\":ans&#125;r = session.get(url,params=answ)print(r.text) 代码逻辑如下：依然是requests+BeautifulSoup获取页面内容，截取img标签src属性中的base64部分后解码，将text部分提取出来后带入二重循环，保证将每个字母按照x坐标的顺序加入到ans字符串中。最后将结果作为参数再次请求得到flag。 这里先按x坐标排序后再逐个提取字母速度更快，不过对python的数据结构不甚了解，未能实现。Python的学习有待加强。通过这个题目练习了requests、base64和BeautifulSoup的使用。 Basic PHP这题在bugku里见过，点开题目即可看到代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Exercise&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;PHP's basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt;&lt;?phprequire_once('flag.php');if (isset($_GET['name']) and isset($_GET['password']) &amp;&amp; isset($_GET['test']))&#123; // ========== Stage 1 ========== $test=$_GET['test']; $test=md5($test); if($test=='0') &#123; print 'You passed stage 1.&lt;br /&gt;'; &#125; else&#123; print \"Game over at stage 1.\"; exit(); &#125; // ========== Stage 2 ========== if ($_GET['name'] == $_GET['password'])&#123; print 'Your password can not be your name.'; exit(); &#125; else if (sha1($_GET['name']) === sha1($_GET['password']))&#123; print 'You passed stage 2.&lt;br /&gt;'; print 'Flag: '.$flag; &#125; else&#123; print 'Invalid password'; exit(); &#125;&#125;echo '&lt;hr /&gt;';show_source(__FILE__);?&gt;&lt;/body&gt;&lt;/html&gt; 输入name、password和test三个参数即可进入stage1，接下来是md5()漏洞的一个考察： PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，其中存在一个缺陷，就是它把每个以“0E”开头的哈希值都解析为0后再进行比较。所以，两个不同的密码经过md5()哈希以后，其哈希值都是以“0E”开头的话，那么PHP将会认为他们是相等的，都是0。 根据这个特性，找到一些md5后产生“0E”开头的字符串作为test的值： 123456QNKCDZO240610708s878926199as155964671as214587387as214587387a 随后进入stage2，我们发现题目要求name和password的值不同，而sha1的结果相同。想找到这种碰撞的概率太低了，此处考察了 sha1() 和 md5() 处理数组时会直接返回null，那么可以使 name 和 password为数组类型，sha1 对数组处理后返回 null 绕过 ===(===会判断左右两边的类型和值是否相同) 。 此时可以令name[]=0&amp;password[]=1，即可得到flag。 问题：令name[]=0&amp;password[]=0为什么不行？总之会返回null，值是0还是1会有影响吗 payload:http://vps1.blue-whale.me:23331/feature/?test=s878926199a&password[]=0&name[]=1 Basic PHP 2 题目给出要求getshell，联想到一句话木马，在这个框中随意输入内容，点击start进入新的页面： 在文本框输入一些内容后点击提交，回显success，此时再点击上面的./config.php会发现之前在文本框中的内容已被写入config.php。再结合下面的代码来看： 123456789101112&lt;?phpif(isset($_GET['content']))&#123; $filename = 'config.php'; $content = $_GET['content']; if(is_int(stripos($content, 'php')) || is_int(stripos($content, '&lt;'))) &#123; echo 'Invalid input'; &#125; else &#123; file_put_contents($filename, $content); echo 'Success'; &#125;&#125; stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。strpos() 函数查找字符串在另一字符串中第一次出现的位置（大小写敏感）。 意思已经比较明显了，我们可以通过content这个参数修改config.php中的内容，但是若想写入php一句话木马，就无法通过stripos()的检验(可以看到对php和&lt; 这两个字符串做了检测 )，此时可以利用strpos传入数组时会返回null，经is_int判断后返回false，即可绕过第一个条件判断（看起来stripos也存在这个问题）；这时候就可以通过file_put_content将一句话木马写入config.php了(其实只写一个&lt;即可得到flag)。 payload:http://vps1.blue-whale.me:23360/user/b4466a4c89f48932020df576d9a77e41902f5a0e/index.php?content[]=","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"}]},{"title":"毕业设计笔记","date":"2020-01-20T08:11:02.000Z","path":"2020-01-20/毕业设计笔记/","text":"随着近几年机器学习的迅速发展,许多研究人员使用机器学习算法来解决异常检测领域的难题,并且取得了许多实验成果。请利用该方法尝试实现小型网络的监控。可以利用KDD99数据库。 网络异常流量检测研究数据集选择 KDD99该数据集是从一个模拟的美国空军局域网上采集来的9个星期的网络连接数据,分成具有标识的训练数据和未加标识的测试数据。测试数据和训练数据有着不同的概率分布,测试数据包含了一些未出现在训练数据中的攻击类型,这使得入侵检测更具有现实性。 NSL-KDD该数据集解决了KDD99数据集中存在的固有问题。NSL-KDD数据集由于缺少基于入侵检测网络的公共数据集，所以NSL-KDD数据集仍然存在一些问题，同时也不是现有真实网络的完美代表。但它仍然可以用作有效的基准数据集，以帮助研究人员比较不同的入侵检测方法。NSL-KDD训练集和测试集的设置是合理的，不同研究工作的评估结果将是一致的和可比的。二者具体区别见下： It does not include redundant records in the train set, so the classifiers will not be biased towards more frequent records. NSL-KDD数据集的训练集中不包含冗余记录，所以分类器不会偏向更频繁的记录； There is no duplicate records in the proposed test sets; therefore, the performance of the learners are not biased by the methods which have better detection rates on the frequent records. NSL-KDD数据集的测试集中没有重复的记录，使得检测率更为准确。 The number of selected records from each difficultylevel group is inversely proportional to the percentage of records in the original KDD data set. As a result, the classification rates of distinct machine learning methods vary in a wider range, which makes it more efficient to have an accurate evaluation of different learning techniques. 来自每个难度级别组的所选记录的数量与原始KDD数据集中的记录的百分比成反比。结果，不同机器学习方法的分类率在更宽的范围内变化，这使得对不同学习技术的准确评估更有效。 The number of records in the train and test sets are reasonable, which makes it affordable to run the experiments on the complete set without the need to randomly select a small portion. Consequently, evaluation results of different research works will be consistent and comparable. 训练和测试中的记录数量设置是合理的，这使得在整套实验上运行实验成本低廉而无需随机选择一小部分。因此，不同研究工作的评估结果将是一致的和可比较的。 常用的深度学习算法","tags":[{"name":"IDS","slug":"IDS","permalink":"https://purewhitywhite.github.io/tags/IDS/"}]},{"title":"我的第一篇博客","date":"2019-06-01T13:39:12.000Z","path":"2019-06-01/我的第一篇博客/","text":"Better late than never,huh?","tags":[]}]